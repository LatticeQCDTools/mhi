
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Package documentation &#8212; Multi-Hadron Interpolators</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="_static/documentation_options.js?v=f2a433a1"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'code';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Overview" href="index.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
  
    <p class="title logo__title">Multi-Hadron Interpolators</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="#">
                        Package documentation
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary" tabindex="0">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="#">
                        Package documentation
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page">Package...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="package-documentation">
<h1>Package documentation<a class="headerlink" href="#package-documentation" title="Link to this heading">#</a></h1>
<section id="module-mhi.mhi">
<span id="main-module"></span><h2>Main module<a class="headerlink" href="#module-mhi.mhi" title="Link to this heading">#</a></h2>
<p>MHI – “Multi-Hadron Interpolators”</p>
<p>Module for constructing block-diagonalization / change-of-basis matrices to map
products of N local plane-wave operators into irreps of the cubic group.
Includes appropriate generalizations for spin and internal symmetries.</p>
<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.mhi">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">mhi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">momenta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_irreps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#mhi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.mhi" title="Link to this definition">#</a></dt>
<dd><p>General-purpose driver function for construction of change-of-basis /
block-diagonalization matrices which project linear combinations of plane-
wave states onto irreps of the cubic group.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>momenta</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(nparticles,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">)</span></code> array_like</span></dt><dd><p>The ordered momenta.</p>
</dd>
<dt><strong>particle_names</strong><span class="classifier">array_like</span></dt><dd><p>The particle names, e.g., [‘n’, ‘p’].</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>Whether or not to print extra diagnostic information.</p>
</dd>
<dt><strong>return_Dmm</strong><span class="classifier">bool</span></dt><dd><p>Whether or not to return the momentum-(spin) representation matrices.</p>
</dd>
<dt><strong>internal_symmetry</strong><span class="classifier">list of <a class="reference internal" href="#mhi.mhi.WeightedPermutation" title="mhi.mhi.WeightedPermutation"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeightedPermutation</span></code></a></span></dt><dd><p>The exchange group projector defined in the group algebra.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier"><a class="reference internal" href="#mhi.mhi.IrrepDecomposition" title="mhi.mhi.IrrepDecomposition"><code class="xref py py-class docutils literal notranslate"><span class="pre">IrrepDecomposition</span></code></a></span></dt><dd><p>object containing the results of the irrep decomposition.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>The algorithm is as follows:</dt><dd><ul class="simple">
<li><p>Compute the little group of the total momentum</p></li>
<li><p>Compute irrep matrices of the little group, <span class="math notranslate nohighlight">\(D_{\mu\nu}(R)\)</span></p></li>
<li><p>Compute the momentum(-spin) representation matrices, <span class="math notranslate nohighlight">\(D_{mm'}(R)\)</span></p></li>
<li><p>Apply exchange-group projection, giving <span class="math notranslate nohighlight">\(\hat{D}(R) = P D(R) P\)</span></p></li>
<li><p>Apply Schur’s algorithm and transition operators to construct the
block-diagonalization matrices</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mhi.mhi.WeightedPermutation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">WeightedPermutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#WeightedPermutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.WeightedPermutation" title="Link to this definition">#</a></dt>
<dd><p>A complex scalar weight times a permutation group element.</p>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>weight</strong><span class="classifier">complex or float</span></dt><dd><p>Scalar weight multiplying the permutation.</p>
</dd>
<dt><strong>perm</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,)</span></code> ndarray</span></dt><dd><p>Permutation expressed as an array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mhi.mhi.Isomorphism">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">Isomorphism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#Isomorphism"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.Isomorphism" title="Link to this definition">#</a></dt>
<dd><p>The group element and permutation specifying a subgroup isomorphism.</p>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>g</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd><p>Group element used to conjugate the subgroup as
<span class="math notranslate nohighlight">\(g \cdot H \cdot g^{-1}\)</span></p>
</dd>
<dt><strong>perm</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|H|,)</span></code> ndarray</span></dt><dd><p>Permutation p mapping from conjugated elements to target subgroup as
<span class="math notranslate nohighlight">\(H' = g \cdot H \cdot g^{-1}[p]\)</span></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mhi.mhi.SpinShellTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">SpinShellTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">momenta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#SpinShellTuple"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.SpinShellTuple" title="Link to this definition">#</a></dt>
<dd><p>Pairing of momenta and spins making up an orbit with non-zero spins.</p>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>momenta</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(norbit,</span> <span class="pre">nmomenta,</span> <span class="pre">3)</span></code> ndarray</span></dt><dd><p>List of momentum lists in the orbit.</p>
</dd>
<dt><strong>spins</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(norbit,</span> <span class="pre">nspin)</span></code> ndarray</span></dt><dd><p>List of spin configurations in the orbit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.levi_civita">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">levi_civita</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#levi_civita"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.levi_civita" title="Link to this definition">#</a></dt>
<dd><p>The totally antisymmetric Levi-Civita tensor in arbitrary dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The number of dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">ndarray</span></dt><dd><p>The Levi-Civita tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Implementation from StackOverflow user JGibs:
<a class="reference external" href="https://stackoverflow.com/questions/59740966/levi-civita-tensor-in-numpy">https://stackoverflow.com/questions/59740966/levi-civita-tensor-in-numpy</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.unique_permutations">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">unique_permutations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#unique_permutations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.unique_permutations" title="Link to this definition">#</a></dt>
<dd><p>Yield only unique permutations of seq in an efficient way.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seq: array_like</strong></dt><dd><p>The elements to be permuted</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>seq: array_like</dt><dd><p>The permuated sequences</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A python implementation of Knuth’s “Algorithm L”, also known from the
std::next_permutation function of C++, and as the permutation algorithm
of Narayana Pandita.</p>
<p>Code taken from a post by StackOverflow user Lauritz V. Thaulow:
<a class="reference external" href="https://stackoverflow.com/questions/12836385/how-can-i-interleave-or-create-unique-permutations-of-two-strings-without-recur/12837695#12837695">https://stackoverflow.com/questions/12836385/how-can-i-interleave-or-create-unique-permutations-of-two-strings-without-recur/12837695#12837695</a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
<span class="go">[1, 1, 2]</span>
<span class="go">[1, 2, 1]</span>
<span class="go">[2, 1, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]</span>
<span class="go">[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="go">[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;]</span>
<span class="go">[&#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="go">[&#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="go">[&#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;]</span>
<span class="go">[&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.symmetrize">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">symmetrize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#symmetrize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.symmetrize" title="Link to this definition">#</a></dt>
<dd><p>Computes the completely symmetrized version of the input array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">array_like</span></dt><dd><p>A tensor of arbitrary rank.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arr_sym</strong><span class="classifier">ndarray</span></dt><dd><p>The completely symmetrized version of the input tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In index notation symmetrization is the map which sends
<span class="math notranslate nohighlight">\(T_{ij...n} \to T_{(ij...n)}\)</span>,
where parantheses denote symmetrization.
For instance, the symmetrization of a three-index tensor
<span class="math notranslate nohighlight">\(T_{ijk}\)</span>
is
<span class="math notranslate nohighlight">\(T_{(ijk)} = \tfrac{1}{6}(T_{ijk} + T_{ikj} + T_{jik} + T_{jki} + T_{kij} + T_{kji})\)</span></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.tensor_product">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">tensor_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#tensor_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.tensor_product" title="Link to this definition">#</a></dt>
<dd><p>Computes the tensor product between tensors a and b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a, b</strong><span class="classifier">array_like</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">array_like</span></dt><dd><p>The tensor product of arrays <cite>a</cite> and <cite>b</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In index notation, this fuction computes the output tensor T defined by
<span class="math notranslate nohighlight">\(T_{ij \dots k rs \dots t} = a_{ij \dots k} b_{rs \dots t}\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.tensor_nfold">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">tensor_nfold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">tensors</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#tensor_nfold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.tensor_nfold" title="Link to this definition">#</a></dt>
<dd><p>Computes the n-fold tensor product between all the tensors in a list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensors</strong><span class="classifier">(variable number of) ndarray</span></dt><dd><p>The input tensors for the product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">ndarray</span></dt><dd><p>The product of all the tensors.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Suppose the input tensors are
<span class="math notranslate nohighlight">\(\{a_i, b_{jk}, c_{lmn}\}\)</span>.
This function computes the output tensor T defined by
<span class="math notranslate nohighlight">\(T_{ijklmn} = a_i b_{jk} c_{lmn}\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.decompose">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">monomial</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#decompose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.decompose" title="Link to this definition">#</a></dt>
<dd><p>Decomposes a sympy monomial of the form
<code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">*</span> <span class="pre">x**nx</span> <span class="pre">*</span> <span class="pre">y**ny</span> <span class="pre">*</span> <span class="pre">z**nz</span></code>
into a coefficient <cite>c</cite> and a triplet of exponents <code class="docutils literal notranslate"><span class="pre">(nx,</span> <span class="pre">ny,</span> <span class="pre">nz)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>monomial</strong><span class="classifier">sympy.core.mul.Mul</span></dt><dd><p>A monomial in the variables {‘x’, ‘y’, ‘z’}</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>(coeff, exponents)</strong><span class="classifier">(complex, tuple)</span></dt><dd><p>The coefficient and exponents (nx, ny, nz) of the monomial</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.compute_polarization">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">compute_polarization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">monomial</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#compute_polarization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.compute_polarization" title="Link to this definition">#</a></dt>
<dd><p>Computes the polarization tensor of a given monomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>monomial</strong><span class="classifier">sympy.core.mul.Mul</span></dt><dd><p>A monomial in the variables {‘x’, ‘y’, ‘z’}</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>polarization_tensor</strong><span class="classifier">ndarray</span></dt><dd><p>The polarization, a totally symmetric tensor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.contract_across">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">contract_across</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#contract_across"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.contract_across" title="Link to this definition">#</a></dt>
<dd><p>Conctract a vector full across all the free indices, yielding a scalar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">array_like</span></dt><dd><p>Tensor of generic rank</p>
</dd>
<dt><strong>vec</strong><span class="classifier">array_like</span></dt><dd><p>The vector to contract against all the free indices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scalar</strong><span class="classifier">float or complex</span></dt><dd><p>The product c = vec[i]*vec[j]*…*vec[n]*arr[i,j,…,n]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.compute_restitution">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">compute_restitution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polarization</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#compute_restitution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.compute_restitution" title="Link to this definition">#</a></dt>
<dd><p>Computes the monomial restitution of a polarization tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>polarization</strong><span class="classifier">array_like</span></dt><dd><p>The (completely symmetric) polarization tensor</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>restitution</strong><span class="classifier">monomial (sympy.core.mul.Mul)</span></dt><dd><p>The monomial resulting from contracting the vector [x,y,z] across all
the free indices of the polarization tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.polarize">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">polarize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fcn</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#polarize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.polarize" title="Link to this definition">#</a></dt>
<dd><p>Computes the polarization tensor associated with a basis function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fcn</strong><span class="classifier">sympy basis function</span></dt><dd><p>The basis function, a sum of monomials in {‘x’, ‘y’, ‘z’}.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">ndarray</span></dt><dd><p>The polarization tensor of rank d, where d is the degree of the
monomials within the basis function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.transform">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.transform" title="Link to this definition">#</a></dt>
<dd><p>Computes the “rotation” transformation of a tensor of arbitrary rank,
A[a,b,…,c] –&gt; R[a,x] R[b,y] … R[c,z] A[x,y,…,z].</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>arr</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">M,</span> <span class="pre">...,</span> <span class="pre">M)</span></code> array_like</span></dt><dd><p>The tensor to transform.</p>
</dd>
<dt><strong>group_element</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">M)</span></code> array_like</span></dt><dd><p>The group element applying the transformation.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>Whether to print the indices used in Einstein summation notation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arr_transformed</strong><span class="classifier">ndarray</span></dt><dd><p>The transformed tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.tensor_inner">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">tensor_inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#tensor_inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.tensor_inner" title="Link to this definition">#</a></dt>
<dd><p>Computes the inner product between two tensors a[i,j,…,k]*b[i,j,…,k].</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">M,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">M)</span></code> array_like</span></dt><dd></dd>
<dt><strong>b</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">M,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">M)</span></code> array_like</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>c</strong><span class="classifier">float or complex</span></dt><dd><p>The result of the inner product across all free indices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_tensor_product_space">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_tensor_product_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_tensor_product_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_tensor_product_space" title="Link to this definition">#</a></dt>
<dd><p>Makes a tensor product space with the specified dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>Integers specifying the dimensions</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor_product_space</strong><span class="classifier">ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>These spaces arise naturally in the construction of combined “momentum-
spin” orbits below. For the portion of the orbit associated with spin,
it’s assumed that the spin has already been decomposed into irreps of
known dimensions. By definition of the irrep space, group transformation
simply permute the basis elements of the irrep space.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">make_tensor_product_space</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(6, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="go">array([</span>
<span class="go">    [0, 0, 0],</span>
<span class="go">    [0, 0, 1],</span>
<span class="go">    [0, 0, 2],</span>
<span class="go">    [0, 1, 0],</span>
<span class="go">    [0, 1, 1],</span>
<span class="go">    [0, 1, 2]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mhi.mhi.DiracPauli">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">DiracPauli</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#DiracPauli"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.DiracPauli" title="Link to this definition">#</a></dt>
<dd><p>Wrapper for Dirac matrices in the Dirac-Pauli basis.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mhi.mhi.DiracPauli.rotation_vec">
<span class="sig-name descname"><span class="pre">rotation_vec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#DiracPauli.rotation_vec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.DiracPauli.rotation_vec" title="Link to this definition">#</a></dt>
<dd><p>Computes the spinor rotation matrix associated with the 3-vector omega.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>omega: ``(3,)`` ndarray or list</strong></dt><dd><p>The vector specifying the rotation</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>arr</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(4,</span> <span class="pre">4)</span></code> ndarray</span></dt><dd><p>The complex roation matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mhi.mhi.DiracPauli.rotation">
<span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#DiracPauli.rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.DiracPauli.rotation" title="Link to this definition">#</a></dt>
<dd><p>Computes the spinor rotation matrix associated with an rotation
of angle “theta” around the kth axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta: float</strong></dt><dd><p>The rotation angle</p>
</dd>
<dt><strong>direction: int</strong></dt><dd><p>The axis number, with {1,2,3} &lt;–&gt; {x,y,z}.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>arr</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(4,</span> <span class="pre">4)</span></code> ndarray</span></dt><dd><p>The complex rotation matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.get_nprod">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">get_nprod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#get_nprod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.get_nprod" title="Link to this definition">#</a></dt>
<dd><p>Gets the number of spin-1/2 copies present for a given half-integer j.</p>
<p>For example, 3/2 = 1/2 otimes 1/2 otimes 1/2 –&gt; 3 copies</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">int or float</span></dt><dd><p>The total spin.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of spin-1/2 copies present.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_spinor_array">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_spinor_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spinor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_spinor_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_spinor_array" title="Link to this definition">#</a></dt>
<dd><p>Builds a normalized “state” with total (j, jz, parity) inside a suitable
tensor product space of spin-1/2 states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>spinor</strong><span class="classifier">SpinorTuple</span></dt><dd><p>The namedtuple specifying (j, jz, parity)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vec</strong><span class="classifier">ndarray</span></dt><dd><p>The normalized vector of length 4**(2*j)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_oh">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_oh</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_oh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_oh" title="Link to this definition">#</a></dt>
<dd><p>Constructs a presentation of the cubic group Oh with a standardized
ordering of group elements.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(48,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.rotation">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.rotation" title="Link to this definition">#</a></dt>
<dd><p>Computes the rotation matrix by the angle theta around a particular axis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">float</span></dt><dd><p>The angle</p>
</dd>
<dt><strong>direction: int</strong></dt><dd><p>The axis number, with {1,2,3} &lt;–&gt; {x,y,z}.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>arr</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> ndarray</span></dt><dd><p>The rotation matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.rotation_vec">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">rotation_vec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#rotation_vec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.rotation_vec" title="Link to this definition">#</a></dt>
<dd><p>Computes the rotation matrix associated with the three-vector omega.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>omega</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">)</span></code> ndarray or list</span></dt><dd><p>The vector defining the rotation</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>arr</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> ndarray</span></dt><dd><p>The rotation matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_ohd">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_ohd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_ohd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_ohd" title="Link to this definition">#</a></dt>
<dd><p>Constructs a presentation of the “spinorial” double cover OhD of
the cubic group ordering of group elements.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>None</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(96,</span> <span class="pre">4,</span> <span class="pre">4)</span></code> ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_spinorial_little_group">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_spinorial_little_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">little</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_spinorial_little_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_spinorial_little_group" title="Link to this definition">#</a></dt>
<dd><p>Makes the “spinorial” little group associated with the double cover OhD,
given a little group G in Oh.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>little</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The little group G.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(2*|G|,</span> <span class="pre">4,</span> <span class="pre">4)</span></code> ndarray</span></dt><dd><p>The double-cover little group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_stabilizer">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_stabilizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">momenta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_stabilizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_stabilizer" title="Link to this definition">#</a></dt>
<dd><p>Constructs the stabilizer subgroup of an ordered set of momenta.
The stabilizer group is the subgroup that leaves the ordered set invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>momenta</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(nmomenta,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">)</span></code> array_like</span></dt><dd><p>The ordered set of momenta that must be left invariant.</p>
</dd>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The total group.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>stabilizer</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|H|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> ndarray</span></dt><dd><p>The stabilizer group H.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_canonical_stabilizer">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_canonical_stabilizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_canonical_stabilizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_canonical_stabilizer" title="Link to this definition">#</a></dt>
<dd><p>Computes the stabilizer subgroup with a canonical orientation inside the
larger group Oh.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name of the desired stabilizer subgroup</p>
</dd>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The group</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>stabilizer</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|H|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The stabilizer subgroup</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.identify_stabilizer">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">identify_stabilizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stabilizer</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#identify_stabilizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.identify_stabilizer" title="Link to this definition">#</a></dt>
<dd><p>Identifies the name of the stabilizer group “H” by checking its order.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>stabilizer</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|H|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The stabilizer group.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name of the stabilizer group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_little_and_stabilizer">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_little_and_stabilizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">momenta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_little_and_stabilizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_little_and_stabilizer" title="Link to this definition">#</a></dt>
<dd><p>Computes the little group and stabilizer group of the ordered set of momenta.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>momenta</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(nmomenta,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The momenta</p>
</dd>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The group</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>groups</strong><span class="classifier">tuple = (ndarray, ndarray)</span></dt><dd><p>A pair of groups arranged as (“little group”, “stabilizer group”)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A word on physics naming conventions.
Let G be a group, let momenta be a set of ordered momenta, and let
ktot be the total momentum (i.e., the sum of the momenta).
The “little group” is the subgroup of G that leaves ktot invariant.
The “stabilizer group” is the subgroup of G that leaves momenta invariant.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.conjugate">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.conjugate" title="Link to this definition">#</a></dt>
<dd><p>Computes the conjugate of group element h by group element g:
<span class="math notranslate nohighlight">\(g.h.g^{-1}\)</span>.  Assumes that g is an orthogonal matrix so that
<span class="math notranslate nohighlight">\(g^{-1} = g^T\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>g</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd></dd>
<dt><strong>h</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>h_conj</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd><p>The conjugated element, <span class="math notranslate nohighlight">\(g.h.g^{-1}\)</span></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.conjugate_group">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">conjugate_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#conjugate_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.conjugate_group" title="Link to this definition">#</a></dt>
<dd><p>Computes the conjugate of the group G by the group element g: <span class="math notranslate nohighlight">\(g.G.g^{-1}\)</span>.
Assumes that g is an orthogonal matrix so that <span class="math notranslate nohighlight">\(g^{-1} = g^T\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd><p>The group G.</p>
</dd>
<dt><strong>h</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd><p>The conjugating element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>group_conj</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd><p>The conjugated group <span class="math notranslate nohighlight">\(g.G.g^{-1}\)</span></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.find_subgroup_isomorphism">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">find_subgroup_isomorphism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subgroup_h1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subgroup_h2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#find_subgroup_isomorphism"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.find_subgroup_isomorphism" title="Link to this definition">#</a></dt>
<dd><p>Finds the isomorphism between conjugate subgroups H1 and H2.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd><p>The group G.</p>
</dd>
<dt><strong>subgroup_h1</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|H|,</span> <span class="pre">n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd><p>The subgroup H1.</p>
</dd>
<dt><strong>subgroup_h2</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|H|,</span> <span class="pre">n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd><p>The subgroup H2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>(g, perm)</strong><span class="classifier"><a class="reference internal" href="#mhi.mhi.Isomorphism" title="mhi.mhi.Isomorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">Isomorphism</span></code></a></span></dt><dd><p>The group element and permutation specifying the isomorphism.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.apply_isomorphism">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">apply_isomorphism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isomorphism</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#apply_isomorphism"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.apply_isomorphism" title="Link to this definition">#</a></dt>
<dd><p>Applies the isomorphism (g, perm) to the group G via <span class="math notranslate nohighlight">\((g.G.g^{-1})[perm]\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd></dd>
<dt><strong>isomorphism</strong><span class="classifier"><a class="reference internal" href="#mhi.mhi.Isomorphism" title="mhi.mhi.Isomorphism"><code class="xref py py-class docutils literal notranslate"><span class="pre">Isomorphism</span></code></a></span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>group_iso</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd><p>The group after applying the isomorphism, <span class="math notranslate nohighlight">\((g.G.g^{-1})[perm]\)</span></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.force_hash">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">force_hash</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#force_hash"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.force_hash" title="Link to this definition">#</a></dt>
<dd><p>Computes a hash for an array.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mhi.mhi.HashableArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">HashableArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#HashableArray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.HashableArray" title="Link to this definition">#</a></dt>
<dd><p>Minimal wrapper to make arrays hashable based on their value at
initialization. Basically copied from the docs:
<a class="reference external" href="https://docs.scipy.org/doc/numpy/user/basics.subclassing.html">https://docs.scipy.org/doc/numpy/user/basics.subclassing.html</a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mhi.mhi.MomentumSpinOrbitElement">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">MomentumSpinOrbitElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">momenta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#MomentumSpinOrbitElement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.MomentumSpinOrbitElement" title="Link to this definition">#</a></dt>
<dd><p>Wrapper for easy manipulations involving elements of momentum-spin orbits.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_momentum_orbit">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_momentum_orbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">momenta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exchange_group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_momentum_orbit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_momentum_orbit" title="Link to this definition">#</a></dt>
<dd><p>Computes the orbit of an ordered set of vectors under a group action.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>momenta</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(nmomenta,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The ordered momenta.</p>
</dd>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The group matrices.</p>
</dd>
<dt><strong>exchange_group</strong><span class="classifier">list of <a class="reference internal" href="#mhi.mhi.WeightedPermutation" title="mhi.mhi.WeightedPermutation"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeightedPermutation</span></code></a></span></dt><dd><p>The exchange group projector.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>orbit</strong><span class="classifier">list</span></dt><dd><p>The matrices corresponding to ordered momenta in the orbit.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In abstract algebra, an orbit is often considered as an unordered set.
For numerical work, it is useful to work with orbits ordered in a standard
way. The convention in the present work is that the orbit inherits its
order from that of the group elements acting on the original starting
vector (or ordered list of vectors.) When a given (set of) vector(s) arises
more than once, the first instance defines the location of the vector(s)
within the orbit.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_momentum_spin_orbit">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_momentum_spin_orbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">momenta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin_dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exchange_group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_momentum_spin_orbit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_momentum_spin_orbit" title="Link to this definition">#</a></dt>
<dd><p>Computes the momentum-spin orbit, i.e., the tensor product of the
momentum orbit and the associated spinor orbit.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>momenta</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(nmomenta,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The ordered momenta</p>
</dd>
<dt><strong>spin_dims</strong><span class="classifier">list of ints</span></dt><dd><p>The dimensions of the spinor spaces.</p>
</dd>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The group matrices.</p>
</dd>
<dt><strong>exchange</strong><span class="classifier">array_like or None</span></dt><dd><p>The exchange_group with namedtuple/WeightedPermutation elements</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spin_shell</strong><span class="classifier">ndarray</span></dt><dd><p>The flattened tensor product.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Consider a spinor transforming in an N-dimensional irrep.
By definition, the different basis vectors for the irrep transform
into each other under the action of the group.
Thus, the spinorial part of the shell is just the tensor product
of all the individual spinor spaces.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.parity">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">parity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">permutation</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#parity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.parity" title="Link to this definition">#</a></dt>
<dd><p>Computes the parity of permutation, assumed to be specified as a list of
contiguous integers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>permutation: array_like</strong></dt><dd><p>The permutation</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>sign: +1 or -1</dt><dd><p>The parity.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parity</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parity</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">-1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.partition">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#partition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.partition" title="Link to this definition">#</a></dt>
<dd><p>Computes the partitions of the array according to the unique elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">array_like</span></dt><dd><p>The array to partition</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>partitions</strong><span class="classifier">dict</span></dt><dd><p>The partitions, where the keys are the unique entries of the input array
and the values are the associated indices in the input array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The keys are sorted according to the first appearance in arr</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">partition</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]))</span>
<span class="go">{&#39;a&#39;: array([0]), &#39;b&#39;: array([1, 2]), &#39;c&#39;: array([3])}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.recombine">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">recombine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_keys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_idxs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#recombine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.recombine" title="Link to this definition">#</a></dt>
<dd><p>Recombines indices from partitioned sets.
This function is equivalent to concatenating the indices for contiguous labels.
For instance, [‘b1’, ‘b1’, ‘b2] are contiguous, but [‘b1’, ‘b2’, ‘b1’] are not.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>labels</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">)</span></code> array_like</span></dt><dd><p>The labels, e.g., [‘b1’, ‘b2’, ‘b1’]</p>
</dd>
<dt><strong>partition_keys</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">)</span></code> array_like</span></dt><dd><p>The unique elements of the labels, ordered by first appearance.</p>
</dd>
<dt><strong>partition_idxs</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">)</span></code> tuple of array_like</span></dt><dd><p>The indices to recombine, in the same order as the partition_keys</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>idxs</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">)</span></code> ndarray</span></dt><dd><p>The recombined indices</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This example builds the tensor product of permutations on the set of labels
[‘b1’,’b2’,’b1’]. Since the label ‘b1’ is not contiguous, the permutations
associated with this label should include the identity (0)(2) and the swap
(0,2).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;b1&#39;</span><span class="p">,</span><span class="s1">&#39;b2&#39;</span><span class="p">,</span><span class="s1">&#39;b1&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">partitions</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perms</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">idxs</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">partitions</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">partitions</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">perms</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">mhi</span><span class="o">.</span><span class="n">recombine</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">idxs</span><span class="p">),</span> <span class="s2">&quot;(correct)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">idxs</span><span class="p">),</span> <span class="s2">&quot;(wrong)&quot;</span><span class="p">)</span>
<span class="go">[0 1 2] (correct)</span>
<span class="go">[0 2 1] (wrong)</span>
<span class="go">[2 1 0] (correct)</span>
<span class="go">[2 0 1] (wrong)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_exchange_projector">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_exchange_projector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tableau_map</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_exchange_projector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_exchange_projector" title="Link to this definition">#</a></dt>
<dd><p>Computes a projector in the group algebra of the particle-exchange group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">list</span></dt><dd><p>Particle labels, e.g., [‘a’,’b’,’c’,’b’,’c’,’b’]</p>
</dd>
<dt><strong>tableau_map</strong><span class="classifier">dict</span></dt><dd><p>Young tableaux associated with each label, e.g.,
{‘a’: [[1]], ‘b’: [[1,2],[3]], ‘c’: [[1],[2]],}</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>projector</strong><span class="classifier">list of WeightedPermutation objects</span></dt><dd><p>The projection operator in the group algebra of the exchange group</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_exchange_projector_identical">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_exchange_projector_identical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_exchange_projector_identical"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_exchange_projector_identical" title="Link to this definition">#</a></dt>
<dd><p>Computes the exchange group associated with exchange of identical particles.
The elements of this group are signed permuations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">array_like or None</span></dt><dd><p>The labels associated with the particles.</p>
</dd>
<dt><strong>fermions</strong><span class="classifier">dict</span></dt><dd><p>Whether a given key (label) corresponds to a fermion.
Values must be booleans: True for fermions and False for bosons.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>exchange_group</strong><span class="classifier">list or None</span></dt><dd><p>The exchange group, with namedtuple/WeightedPermutation elements.
The result is None when no labels are specified.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Generic fermions are labeled ‘f{n}’ for integers n, e.g., ‘f1’, ‘f2, …
Generic bosons are labeld ‘b{n}’ for integers n, e.g., ‘b1’, ‘b2’, …
Support also exists for certain named particles like ‘pi’, ‘K’, ‘neutron’,
‘proton’, ‘nucleon’.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_internal_symmetry_projector">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_internal_symmetry_projector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_symmetry</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_internal_symmetry_projector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_internal_symmetry_projector" title="Link to this definition">#</a></dt>
<dd><p>Computes the projection matrix associated with an internal symmetry group.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>momentum_spin_orbit</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">)</span></code> list of <a class="reference internal" href="#mhi.mhi.SpinShellTuple" title="mhi.mhi.SpinShellTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinShellTuple</span></code></a></span></dt><dd><p>Each element in the list defines the (momenta, spin) configuration for a
given element of the orbit.</p>
</dd>
<dt><strong>internal_group</strong><span class="classifier">list of <a class="reference internal" href="#mhi.mhi.WeightedPermutation" title="mhi.mhi.WeightedPermutation"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeightedPermutation</span></code></a></span></dt><dd><p>The exchange group projector in the group algebra.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>proj</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> ndarray</span></dt><dd><p>projection matrix P, intended to be contracted against the extended
momentum-spin representation matrices, giving projected matrices
<span class="math notranslate nohighlight">\(\hat{D}_{mm'}(R) = P_{mn} D_{nn'}(R) P_{nm'}\)</span></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As a projection matrix, “proj” is idempotent: <code class="docutils literal notranslate"><span class="pre">proj</span> <span class="pre">&#64;</span> <span class="pre">proj</span> <span class="pre">==</span> <span class="pre">proj</span></code>.</p>
<p>The full internal symmetry operator can be thought of as a linear
combination of permutations. The representation matrices can be computed
either before or after taking the linear combination. This implementation
takes the latter route, computing a representation matrix for each and
taking a suitable linear combination.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.multiply_perms">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">multiply_perms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#multiply_perms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.multiply_perms" title="Link to this definition">#</a></dt>
<dd><p>Multiply the permutations a and b.</p>
<p>Group multiplication acts as composition when considering group elements as
left-acting operators, i.e.,
<span class="math notranslate nohighlight">\((a \cdot b)(v) = (a \circ b)(v) = a(b(v))\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>a, b</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,)</span></code> ndarray</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>The product of permutations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.invert_perm">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">invert_perm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#invert_perm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.invert_perm" title="Link to this definition">#</a></dt>
<dd><p>Compute the inverse permutation such that
<span class="math notranslate nohighlight">\(a \circ a^{-1} = a^{-1} \circ a = (1)\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>a</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,)</span></code> array_like</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>ainv</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(n,)</span></code> ndarray</span></dt><dd><p>The inverse permutation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.compose_permutation_algebra_elements">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">compose_permutation_algebra_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#compose_permutation_algebra_elements"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.compose_permutation_algebra_elements" title="Link to this definition">#</a></dt>
<dd><p>Compute the product of two elements in the algebra of the permutation group.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>a, b</strong><span class="classifier">list of <a class="reference internal" href="#mhi.mhi.WeightedPermutation" title="mhi.mhi.WeightedPermutation"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeightedPermutation</span></code></a></span></dt><dd><p>The algebra elements to be multiplied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>The product, as a list of <a class="reference internal" href="#mhi.mhi.WeightedPermutation" title="mhi.mhi.WeightedPermutation"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeightedPermutation</span></code></a> objects.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.algebra_elements_are_close">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">algebra_elements_are_close</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#algebra_elements_are_close"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.algebra_elements_are_close" title="Link to this definition">#</a></dt>
<dd><p>Checks whether elements of the group algebra of Sn are numerically close.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x1, x2</strong><span class="classifier">list of <a class="reference internal" href="#mhi.mhi.WeightedPermutation" title="mhi.mhi.WeightedPermutation"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeightedPermutation</span></code></a> objects</span></dt><dd><p>The group algebra elements.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>are_close</strong><span class="classifier">bool</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.is_valid_tableau">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">is_valid_tableau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tableau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#is_valid_tableau"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.is_valid_tableau" title="Link to this definition">#</a></dt>
<dd><p>Checks whether ragged list is a valid Young tableau.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tableau</strong><span class="classifier">list of lists</span></dt><dd><p>The candidate Young tableau.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_valid</strong><span class="classifier">bool</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.transpose_tableau">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">transpose_tableau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tableau</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#transpose_tableau"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.transpose_tableau" title="Link to this definition">#</a></dt>
<dd><p>Transposes a Young tableau.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tableau</strong><span class="classifier">list of lists</span></dt><dd><p>The tableau, given as a ragged list of integers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tableau_t</strong><span class="classifier">list of lists</span></dt><dd><p>The transposed tableau, as a ragged list of integers.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.symmetrizer">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">symmetrizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#symmetrizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.symmetrizer" title="Link to this definition">#</a></dt>
<dd><p>Computes a symmetrizer over the specified indices.</p>
<p>The symmetrizer is an element of the algebra of the group Sn that yields the
symmetrized or anti-symmetrized (depending on <cite>signed</cite>) space over the
indices in <cite>row</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>row</strong><span class="classifier">array_like</span></dt><dd><p>The (1-indexed) indices over which to symmetrize.</p>
</dd>
<dt><strong>signed</strong><span class="classifier">0 or 1</span></dt><dd><p>Whether to symmetrize (0) or antisymmetrize (1)</p>
</dd>
<dt><strong>n</strong><span class="classifier">The total number of indices</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>The symmetrizer in the group algebra, represented as a list of
WeightedPermutation objects.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Indices less than or equal to 1 are taken from the back of the list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mhi</span><span class="o">.</span><span class="n">symmetrizer</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">signed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[WeightedPermutation(weight=1, perm=array([0, 1, 2])),</span>
<span class="go"> WeightedPermutation(weight=-1, perm=array([1, 0, 2]))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mhi</span><span class="o">.</span><span class="n">symmetrizer</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">signed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[WeightedPermutation(weight=1, perm=array([0, 1, 2])),</span>
<span class="go"> WeightedPermutation(weight=1, perm=array([1, 0, 2]))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mhi</span><span class="o">.</span><span class="n">symmetrizer</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">signed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[WeightedPermutation(weight=1, perm=array([0, 1, 2])),</span>
<span class="go"> WeightedPermutation(weight=1, perm=array([0, 2, 1]))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_young_projector">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_young_projector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tableau</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_young_projector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_young_projector" title="Link to this definition">#</a></dt>
<dd><p>Makes the projection operator, acting on n indices, associated with the
given Young tableau.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tableau</strong><span class="classifier">list of lists</span></dt><dd><p>The Young tableau.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of indices for which to construct the projector.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>proj</strong><span class="classifier">list of WeightedPermutation objects</span></dt><dd><p>The projection operator in the group algebra.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Young tableaux are specified by indices 1,2,3,…. starting with 1.
Indices in python arrays are zero indexed.
This implementation uses definition of the Hermitian projection operators
given by Ref. <a class="reference internal" href="#rb0c009c83ddb-1" id="id1">[1]</a>. In particular, this function uses Eq (86) in Theorem 3
(KS Hermitian Young projectors). For large tableaux, it would likely
advantageous to switch to the Measure Of Lexical Disorder (MOLD) definition
of the projection operators given in Theorem 5.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rb0c009c83ddb-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>J. Alcock-Zeilinger and H. Weigert
“Compact Hermitian Young Projection Operators”
J.Math.Phys. 58 (2017) 5, 051702
[arXiv:1610.10088].</p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_momentum_orbit_rep_matrix">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_momentum_orbit_rep_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_element</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_momentum_orbit_rep_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_momentum_orbit_rep_matrix" title="Link to this definition">#</a></dt>
<dd><p>Computes the momentum-orbit representation matrix associated with the
action of a group element on an orbit of vectors.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>orbit</strong><span class="classifier">list</span></dt><dd><p>The orbit of an ordered set of vectors under the group</p>
</dd>
<dt><strong>group_element</strong><span class="classifier">array_like</span></dt><dd><p>The group element which will act on all the elements of the orbit</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>permutation</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|O|,</span> <span class="pre">|O|)</span></code> ndarray</span></dt><dd><p>The representation matrix, which happens to be a permutation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A group acts on a vector to generate an orbit O. When the group then acts
on the orbit, the result is a permutation of the vectors in the orbit.
The permutation can be represented as a square matrix of size <code class="docutils literal notranslate"><span class="pre">|O|x|O|</span></code>,
where <code class="docutils literal notranslate"><span class="pre">|O|</span></code> is the size of the orbit. The full set of these matrices (with
one for each group element) is itself a group representation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_momentum_orbit_rep">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_momentum_orbit_rep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_momentum_orbit_rep"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_momentum_orbit_rep" title="Link to this definition">#</a></dt>
<dd><p>Computes the representation of a group G acting on an orbit O.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>orbit</strong><span class="classifier">list</span></dt><dd><p>The orbit of an ordered set of vectors under the group</p>
</dd>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The group matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>representation</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">|O|,</span> <span class="pre">|O|)</span></code> ndarray</span></dt><dd><p>The momentum-representation matrices <span class="math notranslate nohighlight">\(D_{m,m'}(R)\)</span> for all
<span class="math notranslate nohighlight">\(R \in G\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_momentum_spin_rep">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_momentum_spin_rep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Dmm</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">Dspin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_momentum_spin_rep"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_momentum_spin_rep" title="Link to this definition">#</a></dt>
<dd><p>Computes the combined momentum-spin representation matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>Dmm</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,|O|,|O|)</span></code> ndarray</span></dt><dd><p>The momentum-representation matrices.</p>
</dd>
<dt><strong>*Dspin</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G^D|,</span> <span class="pre">|\Gamma|,</span> <span class="pre">|\Gamma|)</span></code> ndarray(s)</span></dt><dd><p>The spin irrep matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>Dmm_spin</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G^D|,</span> <span class="pre">dim_total,</span> <span class="pre">dim_total)</span></code> ndarray</span></dt><dd><p>The combined momomentum-spin representation matrices, where the total
dimension is given by dim_total = <code class="docutils literal notranslate"><span class="pre">|O|x|irrep1|x|irrep2|x...x|irrepN|</span></code>.
As should be expected, the proudct includes all the representations
appearing in the list of “Dspin” matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_irrep_matrix">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_irrep_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polarizations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_element</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_irrep_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_irrep_matrix" title="Link to this definition">#</a></dt>
<dd><p>Computes the irrep matrix associated with a group element using the
algebraic method in terms of polarization tensors.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>polarizations</strong><span class="classifier">list</span></dt><dd><p>The polarization tensors specifying the basis functions for the irrep</p>
</dd>
<dt><strong>group_element</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The group element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>irrep_matrix</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|\Gamma|,</span> <span class="pre">|\Gamma|)</span></code> ndarray</span></dt><dd><p>The irrep matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_irrep">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_irrep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polarizations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_irrep"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_irrep" title="Link to this definition">#</a></dt>
<dd><p>Computes the irrep matrices D_{mu, mu’}(g).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>polarizations</strong><span class="classifier">list</span></dt><dd><p>The polarization tensors specifying the basis functions for the irrep.</p>
</dd>
<dt><strong>group: ``(|G|, 3, 3)`` array_like</strong></dt><dd><p>The group matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>irrep</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">|\Gamma|,</span> <span class="pre">|\Gamma|)</span></code> ndarray</span></dt><dd><p>The irrep matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_irrep_matrix_spinor">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_irrep_matrix_spinor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">irrep_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_element</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_irrep_matrix_spinor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_irrep_matrix_spinor" title="Link to this definition">#</a></dt>
<dd><p>Computes the spinorial irrep matrix associated with a group element,
given a basis for the irrep.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>irrep_basis</strong><span class="classifier">list</span></dt><dd><p>The spinor basis spanning the irrep</p>
</dd>
<dt><strong>group_element</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(4,</span> <span class="pre">4)</span></code> ndarray</span></dt><dd><p>The “spinorial” group element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>irrep_matrix</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|\Gamma|,</span> <span class="pre">|\Gamma|)</span></code> ndarray</span></dt><dd><p>The irrep matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Each basis state should be a list of tuples “(coefficient, SpinorTuple)”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_irrep_spinor">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_irrep_spinor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_irrep_spinor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_irrep_spinor" title="Link to this definition">#</a></dt>
<dd><p>Computes the spinorial irrep matrices D_{mu, mu’}(g).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>basis</strong><span class="classifier">list</span></dt><dd><p>The spinor basis spanning the irrep</p>
</dd>
<dt><strong>group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">4,</span> <span class="pre">4)</span></code> list or array_like</span></dt><dd><p>The group matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>irrep</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">|\Gamma|,</span> <span class="pre">|\Gamma|)</span></code> ndarray</span></dt><dd><p>The irrep matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_irrep_from_group">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_irrep_from_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">little_group</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_irrep_from_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_irrep_from_group" title="Link to this definition">#</a></dt>
<dd><p>Computes the irrep matrices associated with a particular little group.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>little_group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> ndarray</span></dt><dd><p>The matrices for the little group G.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Dmumu</strong><span class="classifier">dict</span></dt><dd><p>The irrep matrices as a dict. The keys give the name of the irrep.
The values contain the irrep matrices themselves, each with shape
<code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">|\Gamma|,</span> <span class="pre">|\Gamma|)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_irrep_from_groupD">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_irrep_from_groupD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">little_group</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_irrep_from_groupD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_irrep_from_groupD" title="Link to this definition">#</a></dt>
<dd><p>Computes double-cover irrep matrices associated with a given little group,
including both spinorial and bosonic irreps.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>little_group</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> ndarray</span></dt><dd><p>The matrices for the little group G.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Dmumu_double</strong><span class="classifier">dict</span></dt><dd><p>The irrep matrices as a dict. The keys give the name of the irrep.
The values contain the irrep matrices themselves, each with shape
<code class="docutils literal notranslate"><span class="pre">(|G^D|,</span> <span class="pre">|\Gamma|,</span> <span class="pre">|\Gamma|)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.orth">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">orth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#orth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.orth" title="Link to this definition">#</a></dt>
<dd><p>Computes an orthonormal basis for the row space.</p>
<p>This implementation constructs the basis for the row space using the
Gram-Schmidt algorithm applied to the rows of the input array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">array_like</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">ndarray</span></dt><dd><p>An orthonormal basis for the row space, with each row corresponding to
a basis element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.project">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#project"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.project" title="Link to this definition">#</a></dt>
<dd><p>Computes the paralell or perpendicular projection of a vector with respect
to the space spanned by a basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vector</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>basis</strong><span class="classifier">array_like</span></dt><dd><p>Vectors specifying the basis, with each row corresponding to a vector.</p>
</dd>
<dt><strong>direction</strong><span class="classifier">{‘parallel’, ‘perpendicular’}</span></dt><dd><p>Whether to compute the parallel or perpendicular projection.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vector_new</strong><span class="classifier">np.array</span></dt><dd><p>The projected vector.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.apply_schur">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">apply_schur</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Dmm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dmumu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#apply_schur"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.apply_schur" title="Link to this definition">#</a></dt>
<dd><p>Computes the block diagonalization matrices using Schur’s algorithm,
including transition operators to move between rows in a given irrep.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>Dmm</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">|O|,</span> <span class="pre">|O|)</span></code> array_like</span></dt><dd><p>Momentum-(spin)-representation matrices</p>
</dd>
<dt><strong>Dmumu</strong><span class="classifier">dict</span></dt><dd><p>The irrep matrices. The keys give the name of the irrep. The values
contain the group irrep matrices, with shape <code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">|\Gamma|,</span> <span class="pre">|\Gamma|)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u_matrix</strong><span class="classifier">dict</span></dt><dd><p>The block diagonalization matrix.
The keys are tuples of the form (irrep_name, degeneracy_number).
The values are arrays containing the matrices, each of shape
<code class="docutils literal notranslate"><span class="pre">(|\Gamma|,</span> <span class="pre">|O|)</span></code>.</p>
</dd>
<dt>transition_operators: dict</dt><dd><p>Column of transition operators <code class="docutils literal notranslate"><span class="pre">T_{\mu,0}</span></code>.
The keys are irrep names.
The values are ndarrays of shape <code class="docutils literal notranslate"><span class="pre">(|\Gamma|,</span> <span class="pre">|O|,</span> <span class="pre">|O|)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.rephase">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">rephase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irrep</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#rephase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.rephase" title="Link to this definition">#</a></dt>
<dd><p>Applies a phase convention to block diagonalization matrices</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>arr</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|\Gamma|,</span> <span class="pre">|O|)</span></code> array_like</span></dt><dd><p>Table specifiying the matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>arr</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|\Gamma|,</span> <span class="pre">|O|)</span></code> ndarray</span></dt><dd><p>The table with appropriate phases applied.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>The phase convention is as follows:</dt><dd><ul class="simple">
<li><p>For a generic irrep, the phase is chosen such that the first nonzero
entry of the first row (<span class="math notranslate nohighlight">\(\mu=1\)</span>) is real and positive.</p></li>
<li><p>For the irreps <span class="math notranslate nohighlight">\(T_2^+\)</span> and <span class="math notranslate nohighlight">\(T_2^-\)</span> only, the phase is chosen
such that the second row (<span class="math notranslate nohighlight">\(\mu=2\)</span>) is purely imaginary with a negative
imaginary part. This choice matches the basis-vector conventions of
Basak et al., where a particular combination of spheric harmonics
<span class="math notranslate nohighlight">\((Y_2^2 - Y_2^{-2})\)</span> is used as the <span class="math notranslate nohighlight">\(\mu=2\)</span> basis vector for T2.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r134ac520551a-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>S. Basak et al., “Clebsch-Gordan construction of lattice interpolating
fields for excited baryons”, Phys. Rev. D 72, 074501 (2005),
[arXiv:hep-lat/0508018].</p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.load_particle_info">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">load_particle_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#load_particle_info"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.load_particle_info" title="Link to this definition">#</a></dt>
<dd><p>Loads tabulated information for particle names, spins (boson vs fermion),
and spin irreps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fname</strong><span class="classifier">str or None</span></dt><dd><p>The path to the input yaml file with the tabulated data</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>table</strong><span class="classifier">dict</span></dt><dd><p>The particle information in the form {&lt;name&gt; : (&lt;fermion?&gt;, &lt;irrep&gt;}</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_pseudoscalar_irrep">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_pseudoscalar_irrep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">little</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_pseudoscalar_irrep"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_pseudoscalar_irrep" title="Link to this definition">#</a></dt>
<dd><p>Instantiates the double-cover irrep matrices associated with a pseudoscalar
particle, assumed to transform under the <span class="math notranslate nohighlight">\(A_1^-\)</span> irrep. Usually this
function is used when constructing the <cite>Dspin</cite> matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>little</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The little-group matrices associated with some momenta</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>pseudoscalar</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G^D|,</span> <span class="pre">1,</span> <span class="pre">1)</span></code> ndarray</span></dt><dd><p>The A1m irrep matrices restricted to the double cover of the little group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_spin_half_irrep">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_spin_half_irrep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">little_double</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_spin_half_irrep"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_spin_half_irrep" title="Link to this definition">#</a></dt>
<dd><p>Instantiates the double-cover irrep matrices associated with a spin-half
particle, assumed to transform under the <span class="math notranslate nohighlight">\(G_1^+\)</span> irrep. Usually this
function is used when constructing the <cite>Dspin</cite> matrices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>little_double</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G^D|,</span> <span class="pre">4,</span> <span class="pre">4)</span></code> array_like</span></dt><dd><p>The spinorial little-group matrices associated with some momenta</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>pseudoscalar</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G^D|,</span> <span class="pre">1,</span> <span class="pre">1)</span></code> ndarray</span></dt><dd><p>The G_1^+ irrep matrices restricted to the double cover of the little group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.make_Dspin">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">make_Dspin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spin_irreps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">little</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">little_double</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#make_Dspin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.make_Dspin" title="Link to this definition">#</a></dt>
<dd><p>Builds a list of spin irrep matrices for the specified particles.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>spin_irreps</strong><span class="classifier">list</span></dt><dd><p>The names of the particles’ spin irreps as strings, e.g., [‘A1m’, ‘G1p’]</p>
</dd>
<dt><strong>little</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">3,</span> <span class="pre">3)</span></code> array_like</span></dt><dd><p>The little-group matrices associated with some momenta</p>
</dd>
<dt><strong>little_double</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G^D|,</span> <span class="pre">4,</span> <span class="pre">4)</span></code> array_like</span></dt><dd><p>The spinorial little-group matrices associated with some momenta</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Dspin</strong><span class="classifier">list</span></dt><dd><p>The “spin” irrep matrices for each particle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.identify_spin_dim">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">identify_spin_dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">irrep</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#identify_spin_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.identify_spin_dim" title="Link to this definition">#</a></dt>
<dd><p>Identifies the dimension of the specified spin irrep.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>str</strong><span class="classifier">irrep</span></dt><dd><p>The name of the spin irrep, e.g., ‘A1m’ or ‘G1p’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The dimension of the irrep</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mhi.mhi.IrrepDecomposition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">IrrepDecomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">decomp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dmm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dmumu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">little_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stab_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transition_operators</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#IrrepDecomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.IrrepDecomposition" title="Link to this definition">#</a></dt>
<dd><p>Container for results of computing the block-diagonalization matrices
which project linear combinations of plane-wave states onto irreps of
the cubic group.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>decomp</strong><span class="classifier">dict</span></dt><dd><p>The irrep decomposition and change-of-basis matrices.
The keys are tuples (irrep_name, degeneracy_idx).
The values are the block-diagonalization matrices, given as arrays
of shape <code class="docutils literal notranslate"><span class="pre">(|Gamma|,</span> <span class="pre">|O|)</span></code>.</p>
</dd>
<dt><strong>orbit</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|O|,)</span></code> list of <a class="reference internal" href="#mhi.mhi.SpinShellTuple" title="mhi.mhi.SpinShellTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinShellTuple</span></code></a></span></dt><dd><p>The “extended” spin-momentum orbit, where each element is a
<a class="reference internal" href="#mhi.mhi.SpinShellTuple" title="mhi.mhi.SpinShellTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinShellTuple</span></code></a> specifying momentum and spin indices.</p>
</dd>
<dt><strong>Dmm</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">|O|,</span> <span class="pre">|O|)</span></code>, ndarray</span></dt><dd><p>The (reducible) representation matrices associated with the orbit.</p>
</dd>
<dt><strong>Dmumu</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">|Gamma|,</span> <span class="pre">|Gamma|)</span></code>, ndarray</span></dt><dd><p>The irrep matrices</p>
</dd>
<dt><strong>little_name</strong><span class="classifier">str</span></dt><dd><p>The name of the little group leaving the total momentum invariant</p>
</dd>
<dt><strong>stab_name</strong><span class="classifier">str</span></dt><dd><p>The name of the stabilizer group leaving the ordered set of
momenta invariant.</p>
</dd>
<dt><strong>transition_operators: dict</strong></dt><dd><p>Column of transition operators <span class="math notranslate nohighlight">\(T_{\mu,0}\)</span>.
The keys are irrep names.
The values are ndarrays of shape <code class="docutils literal notranslate"><span class="pre">(|Gamma|,</span> <span class="pre">|O|,</span> <span class="pre">|O|)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Projection onto cubic-group irreps requires two pieces.</dt><dd><ul class="simple">
<li><p>A basis of momentum plane-wave correlation functions, presumably
computed using lattice QCD.</p></li>
<li><p>The block-diagonalization matrices computed using this module.</p></li>
</ul>
</dd>
</dl>
<p>To carry out this projection, the basis of correlation functions must
have the same order as the orbit used to compute the block-diagonalization
matrices. The required ordering can be seen by examining the
“orbit.”</p>
<dl class="py method">
<dt class="sig sig-object py" id="mhi.mhi.IrrepDecomposition.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#IrrepDecomposition.format"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.IrrepDecomposition.format" title="Link to this definition">#</a></dt>
<dd><p>Formats the irrep decomposition as text string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>latex</strong><span class="classifier">bool</span></dt><dd><p>Whether or not return a latex-formatted sting</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">str</span></dt><dd><p>The irrep decomposition, e.g., <code class="docutils literal notranslate"><span class="pre">&quot;A1p</span> <span class="pre">+</span> <span class="pre">A2p</span> <span class="pre">+</span> <span class="pre">2*Ep&quot;</span></code> or
<code class="docutils literal notranslate"><span class="pre">&quot;$A_1^+</span> <span class="pre">\oplus</span> <span class="pre">A_2^+</span> <span class="pre">\oplus</span> <span class="pre">2E^+$&quot;</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mhi.mhi.IrrepDecomposition.little_name">
<span class="sig-name descname"><span class="pre">little_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#IrrepDecomposition.little_name"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.IrrepDecomposition.little_name" title="Link to this definition">#</a></dt>
<dd><p>Returns the name of the little group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>latex</strong><span class="classifier">bool</span></dt><dd><p>Whether or not return a latex-formatted sting</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>little_name</strong><span class="classifier">str</span></dt><dd><p>The name of the little group</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mhi.mhi.IrrepDecomposition.stab_name">
<span class="sig-name descname"><span class="pre">stab_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#IrrepDecomposition.stab_name"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.IrrepDecomposition.stab_name" title="Link to this definition">#</a></dt>
<dd><p>Returns the name of the stabilizer group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>latex</strong><span class="classifier">bool</span></dt><dd><p>Whether or not return a latex-formatted sting</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stab_name</strong><span class="classifier">str</span></dt><dd><p>The name of the stabilizer group</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.test_stabilizer">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">test_stabilizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#test_stabilizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.test_stabilizer" title="Link to this definition">#</a></dt>
<dd><p>Test identification of the stabilizer group by comparing to known results.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.anticommutator">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">anticommutator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#anticommutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.anticommutator" title="Link to this definition">#</a></dt>
<dd><p>Computes the anticommutator of two matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr1</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>arr2</strong><span class="classifier">array_like</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">ndarray</span></dt><dd><p>The anticommutator {arr1, arr2}</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.commutator">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">commutator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#commutator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.commutator" title="Link to this definition">#</a></dt>
<dd><p>Computes the commutator of two matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr1</strong><span class="classifier">array_like</span></dt><dd></dd>
<dt><strong>arr2</strong><span class="classifier">array_like</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">ndarray</span></dt><dd><p>The commutator {arr1, arr2}</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.test_clifford">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">test_clifford</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#test_clifford"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.test_clifford" title="Link to this definition">#</a></dt>
<dd><p>Tests the Clifford-algebra condition,
<span class="math notranslate nohighlight">\(\{\gamma_\mu, \gamma_\nu\} = 2*\eta_{\mu\nu}\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>gamma</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(4,</span> <span class="pre">)</span></code> list or <code class="docutils literal notranslate"><span class="pre">(4,</span> <span class="pre">4,</span> <span class="pre">4)</span></code> array_like</span></dt><dd><p>The gamma matrices gamma[i], i=0,1,2,3.</p>
</dd>
<dt><strong>eta</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(4,4)</span></code> ndarray</span></dt><dd><p>The metric.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>Whether to print additional information about successful tests.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.test_gamma5">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">test_gamma5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#test_gamma5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.test_gamma5" title="Link to this definition">#</a></dt>
<dd><p>Tests anticommutation of gamma5,
<span class="math notranslate nohighlight">\(\{\gamma_\mu, \gamma_5\} = 0\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>gamma</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(4,</span> <span class="pre">)</span></code> list or <code class="docutils literal notranslate"><span class="pre">(4,</span> <span class="pre">4,</span> <span class="pre">4)</span></code> array_like</span></dt><dd><p>The gamma matrices gamma[i], i=0,1,2,3.</p>
</dd>
<dt><strong>gamma5</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(4,4)</span></code></span></dt><dd><p>The matrix gamma5.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>Whether to print additional information about successful tests.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.test_row_orthogonality">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">test_row_orthogonality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#test_row_orthogonality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.test_row_orthogonality" title="Link to this definition">#</a></dt>
<dd><p>Tests the row orthogonality of tables of block-diagonalization matrices,
for a given irrep.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u_matrix</strong><span class="classifier">dict</span></dt><dd><p>The block diagonalization matrix.
The keys are tuples of the form (irrep_name, degeneracy_number).
The values are arrays containing the matrices, each of shape
<code class="docutils literal notranslate"><span class="pre">(|Gamma|,</span> <span class="pre">|O|)</span></code>.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>Whether to print additional information about successful tests.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.count_degeneracy">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">count_degeneracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#count_degeneracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.count_degeneracy" title="Link to this definition">#</a></dt>
<dd><p>Counts the degeneracy of irreps within the tables of block-diagnoalization
matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u_matrix</strong><span class="classifier">dict</span></dt><dd><p>The block diagonalization matrix.
The keys are tuples of the form (irrep_name, degeneracy_number).
The values are arrays containing the matrices, each of shape
<code class="docutils literal notranslate"><span class="pre">(|Gamma|,</span> <span class="pre">|O|)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>degeneracy</strong><span class="classifier">dict</span></dt><dd><p>The degeneracies, with keys corresponding to the irrep names and values
to the counts.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.test_degenerate_orthogonality">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">test_degenerate_orthogonality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#test_degenerate_orthogonality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.test_degenerate_orthogonality" title="Link to this definition">#</a></dt>
<dd><p>Tests that tables corresponding to degenerate irreps are orthogonal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u_matrix</strong><span class="classifier">dict</span></dt><dd><p>The block diagonalization matrix.
The keys are tuples of the form (irrep_name, degeneracy_number).
The values are arrays containing the matrices, each of shape
<code class="docutils literal notranslate"><span class="pre">(|Gamma|,</span> <span class="pre">|O|)</span></code>.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>Whether to print additional information about successful tests.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.test_block_diagonalization">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">test_block_diagonalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Dmm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dmumu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#test_block_diagonalization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.test_block_diagonalization" title="Link to this definition">#</a></dt>
<dd><p>Tests the block diagonalization property of the change-of-basis matrices,
<span class="math notranslate nohighlight">\(D_{\mu\nu} = U^\dagger_{\mu m} D_{mm'} U_{m' \nu}\)</span>
in terms of the given momentum-shell representation <cite>Dmm</cite>, the
block-diagonalization matrix <cite>U</cite>, and the block-diagonal irrep matrix
<cite>Dmumu</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>Dmm</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">(|G|,|O|,|O|)</span></code> ndarray</span></dt><dd><p>The momentum-representation matrices.</p>
</dd>
<dt><strong>Dmumu</strong><span class="classifier">dict</span></dt><dd><p>The irrep matrices as a dict. The keys give the name of the irrep.
The values contain the irrep matrices themselves, each with shape
<code class="docutils literal notranslate"><span class="pre">(|G|,</span> <span class="pre">|Gamma|,</span> <span class="pre">|Gamma|)</span></code>.</p>
</dd>
<dt><strong>u_matrix</strong><span class="classifier">dict</span></dt><dd><p>The block diagonalization matrix.
The keys are tuples of the form (irrep_name, degeneracy_number).
The values are arrays containing the matrix, each of shape
<code class="docutils literal notranslate"><span class="pre">(|Gamma|,</span> <span class="pre">|O|)</span></code>.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>Whether to print additional information about successful tests.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.write_hdf5">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">write_hdf5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h5fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result_dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#write_hdf5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.write_hdf5" title="Link to this definition">#</a></dt>
<dd><p>Writes block-diagonalization matrices to HDF5.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>h5fname</strong><span class="classifier">str</span></dt><dd><p>The name of the output file</p>
</dd>
<dt><strong>result_dict</strong><span class="classifier">dict</span></dt><dd><p>The block-diagonalization / change of basis matrices, where each key
is a tuple the form (irrep_name, degeneracy) and each key is an ndarray
with the associated matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mhi.mhi.read_hdf5">
<span class="sig-prename descclassname"><span class="pre">mhi.mhi.</span></span><span class="sig-name descname"><span class="pre">read_hdf5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h5fname</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/mhi.html#read_hdf5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.mhi.read_hdf5" title="Link to this definition">#</a></dt>
<dd><p>Reads saved block-diagonalization matrices from HDF5.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>h5fname</strong><span class="classifier">str</span></dt><dd><p>The name of HDF5 file to read</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result_dict</strong><span class="classifier">dict</span></dt><dd><p>The block-diagonalization / change of basis matrices, where each key
is a tuple the form (irrep_name, degeneracy) and each key is an ndarray
with the associated matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mhi.basis_functions">
<span id="basis-functions-module"></span><h2>Basis functions module<a class="headerlink" href="#module-mhi.basis_functions" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mhi.basis_functions.SpinorTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">SpinorTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mhi/basis_functions.html#SpinorTuple"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mhi.basis_functions.SpinorTuple" title="Link to this definition">#</a></dt>
<dd><p>A spinor basis state <code class="docutils literal notranslate"><span class="pre">|j,</span> <span class="pre">jz,</span> <span class="pre">parity&gt;</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>j</strong><span class="classifier">float</span></dt><dd><p>The half-integer total spin.</p>
</dd>
<dt><strong>jz</strong><span class="classifier">float</span></dt><dd><p>The half-integer z component of spin.</p>
</dd>
<dt><strong>parity</strong><span class="classifier">+1 or -1</span></dt><dd><p>The parity.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Oh_A1p">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Oh_A1p</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.577350269189626*x**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*y**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*z**2]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Oh_A1p" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A_{1}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Oh_A1m">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Oh_A1m</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.408248290463863*x*y*z*(x**4*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">y**4*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">z**4*(x**2</span> <span class="pre">-</span> <span class="pre">y**2))]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Oh_A1m" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A_{1}^{-}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Oh_A2p">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Oh_A2p</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.408248290463863*x**4*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">0.408248290463863*y**4*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">0.408248290463863*z**4*(x**2</span> <span class="pre">-</span> <span class="pre">y**2)]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Oh_A2p" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A_{2}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Oh_A2m">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Oh_A2m</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[x*y*z]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Oh_A2m" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A_{2}^{-}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Oh_Ep">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Oh_Ep</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[-0.408248290463863*x**2</span> <span class="pre">-</span> <span class="pre">0.408248290463863*y**2</span> <span class="pre">+</span> <span class="pre">0.816496580927726*z**2,</span> <span class="pre">0.707106781186547*x**2</span> <span class="pre">-</span> <span class="pre">0.707106781186547*y**2]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Oh_Ep" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(E^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Oh_Em">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Oh_Em</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[x*y*z*(x**2</span> <span class="pre">-</span> <span class="pre">y**2),</span> <span class="pre">-x*y*z*(-x**2</span> <span class="pre">-</span> <span class="pre">y**2</span> <span class="pre">+</span> <span class="pre">2*z**2)]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Oh_Em" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(E^{-}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Oh_T1m">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Oh_T1m</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[1.4142135623731*z,</span> <span class="pre">-x</span> <span class="pre">+</span> <span class="pre">1.0*I*y,</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1.0*I*y]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Oh_T1m" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(T_1^-\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Oh_T1p">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Oh_T1p</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[1.4142135623731*x*y*(x**2</span> <span class="pre">-</span> <span class="pre">y**2),</span> <span class="pre">1.0*I*x*z*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)</span> <span class="pre">-</span> <span class="pre">y*z*(y**2</span> <span class="pre">-</span> <span class="pre">z**2),</span> <span class="pre">1.0*I*x*z*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">y*z*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Oh_T1p" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(T_1^+\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Oh_T2m">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Oh_T2m</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[1.0*I*x*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)</span> <span class="pre">-</span> <span class="pre">y*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2),</span> <span class="pre">-1.4142135623731*I*z*(x**2</span> <span class="pre">-</span> <span class="pre">y**2),</span> <span class="pre">1.0*I*x*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">y*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Oh_T2m" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(T_2^-\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Oh_T2p">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Oh_T2p</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[-x*z</span> <span class="pre">+</span> <span class="pre">1.0*I*y*z,</span> <span class="pre">-1.4142135623731*I*x*y,</span> <span class="pre">x*z</span> <span class="pre">+</span> <span class="pre">1.0*I*y*z]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Oh_T2p" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(T_2^+\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C4v_A1">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C4v_A1</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.577350269189626*x**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*y**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*z**2]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C4v_A1" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A_{1}\)</span> of <span class="math notranslate nohighlight">\(C_{4v}\)</span> = <span class="math notranslate nohighlight">\(A_{1}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C4v_A2">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C4v_A2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.408248290463863*x*y*z*(x**4*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">y**4*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">z**4*(x**2</span> <span class="pre">-</span> <span class="pre">y**2))]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C4v_A2" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A_{2}\)</span> of <span class="math notranslate nohighlight">\(C_{4v}\)</span> = <span class="math notranslate nohighlight">\(A_{1}^{-}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C4v_B1">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C4v_B1</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.707106781186547*x**2</span> <span class="pre">-</span> <span class="pre">0.707106781186547*y**2]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C4v_B1" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(B_{1}\)</span> of <span class="math notranslate nohighlight">\(C_{4v}\)</span> = <span class="math notranslate nohighlight">\(E_{1}^{+} (\mu=2)\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C4v_B2">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C4v_B2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[-1.4142135623731*I*x*y]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C4v_B2" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(B_{2}\)</span> of <span class="math notranslate nohighlight">\(C_{4v}\)</span> = <span class="math notranslate nohighlight">\(T_2^+ (\mu=2)\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C4v_E">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C4v_E</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[-x*z,</span> <span class="pre">-y*z]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C4v_E" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(E\)</span> of <span class="math notranslate nohighlight">\(C_{4v}\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C3v_A1">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C3v_A1</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.577350269189626*x**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*y**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*z**2]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C3v_A1" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A_{1}\)</span> of <span class="math notranslate nohighlight">\(C_{3v}\)</span> = <span class="math notranslate nohighlight">\(A_{1}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C3v_A2">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C3v_A2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.408248290463863*x**4*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">0.408248290463863*y**4*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">0.408248290463863*z**4*(x**2</span> <span class="pre">-</span> <span class="pre">y**2)]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C3v_A2" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A_{2}\)</span> of <span class="math notranslate nohighlight">\(C_{3v}\)</span> = <span class="math notranslate nohighlight">\(A_{2}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C3v_E">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C3v_E</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[-0.408248290463863*x**2</span> <span class="pre">-</span> <span class="pre">0.408248290463863*y**2</span> <span class="pre">+</span> <span class="pre">0.816496580927726*z**2,</span> <span class="pre">0.707106781186547*x**2</span> <span class="pre">-</span> <span class="pre">0.707106781186547*y**2]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C3v_E" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(E\)</span> of <span class="math notranslate nohighlight">\(C_{3v}\)</span> = <span class="math notranslate nohighlight">\(E_{}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C2v_A1">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C2v_A1</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.577350269189626*x**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*y**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*z**2]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C2v_A1" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A_{1}\)</span> of <span class="math notranslate nohighlight">\(C_{2v}\)</span> = <span class="math notranslate nohighlight">\(A_{1}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C2v_A2">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C2v_A2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.408248290463863*x*y*z*(x**4*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">y**4*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">z**4*(x**2</span> <span class="pre">-</span> <span class="pre">y**2))]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C2v_A2" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A_{2}\)</span> of <span class="math notranslate nohighlight">\(C_{2v}\)</span> = <span class="math notranslate nohighlight">\(A_{1}^{-}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C2v_B1">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C2v_B1</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[x*y*z]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C2v_B1" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(B_{1}\)</span> of <span class="math notranslate nohighlight">\(C_{2v}\)</span> = <span class="math notranslate nohighlight">\(A_{2}^{-}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C2v_B2">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C2v_B2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.408248290463863*x**4*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">0.408248290463863*y**4*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">0.408248290463863*z**4*(x**2</span> <span class="pre">-</span> <span class="pre">y**2)]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C2v_B2" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(B_{2}\)</span> of <span class="math notranslate nohighlight">\(C_{2v}\)</span> = <span class="math notranslate nohighlight">\(A_{2}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C2R_A">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C2R_A</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.577350269189626*x**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*y**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*z**2]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C2R_A" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A\)</span> of <span class="math notranslate nohighlight">\(C_2^R\)</span> = <span class="math notranslate nohighlight">\(A_{1}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C2R_B">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C2R_B</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.408248290463863*x*y*z*(x**4*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">y**4*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">z**4*(x**2</span> <span class="pre">-</span> <span class="pre">y**2))]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C2R_B" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(B\)</span> of <span class="math notranslate nohighlight">\(C_2^R\)</span> = <span class="math notranslate nohighlight">\(A_{1}^{-}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C2P_A">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C2P_A</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.577350269189626*x**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*y**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*z**2]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C2P_A" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A\)</span> of <span class="math notranslate nohighlight">\(C_2^P\)</span> = <span class="math notranslate nohighlight">\(A_{1}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C2P_B">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C2P_B</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.408248290463863*x**4*(y**2</span> <span class="pre">-</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">0.408248290463863*y**4*(-x**2</span> <span class="pre">+</span> <span class="pre">z**2)</span> <span class="pre">+</span> <span class="pre">0.408248290463863*z**4*(x**2</span> <span class="pre">-</span> <span class="pre">y**2)]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C2P_B" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(B\)</span> of <span class="math notranslate nohighlight">\(C_2^P\)</span> = <span class="math notranslate nohighlight">\(A_{2}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C1_A">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C1_A</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[0.577350269189626*x**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*y**2</span> <span class="pre">+</span> <span class="pre">0.577350269189626*z**2]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C1_A" title="Link to this definition">#</a></dt>
<dd><p>Basis functions for irrep <span class="math notranslate nohighlight">\(A\)</span> of <span class="math notranslate nohighlight">\(C_1\)</span> = <span class="math notranslate nohighlight">\(A_{1}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_OhD_G1p">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_OhD_G1p</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(0.5,</span> <span class="pre">0.5,</span> <span class="pre">1))],</span> <span class="pre">[(1,</span> <span class="pre">(0.5,</span> <span class="pre">-0.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_OhD_G1p" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(G_{1}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h^D\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_OhD_G1m">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_OhD_G1m</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(0.5,</span> <span class="pre">0.5,</span> <span class="pre">-1))],</span> <span class="pre">[(1,</span> <span class="pre">(0.5,</span> <span class="pre">-0.5,</span> <span class="pre">-1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_OhD_G1m" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(G_{1}^{-}\)</span> of <span class="math notranslate nohighlight">\(O_h^D\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_OhD_G2p">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_OhD_G2p</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(0.408248290463863,</span> <span class="pre">(2.5,</span> <span class="pre">2.5,</span> <span class="pre">1)),</span> <span class="pre">(-0.9128709291752769,</span> <span class="pre">(2.5,</span> <span class="pre">-1.5,</span> <span class="pre">1))],</span> <span class="pre">[(0.408248290463863,</span> <span class="pre">(2.5,</span> <span class="pre">-2.5,</span> <span class="pre">1)),</span> <span class="pre">(-0.9128709291752769,</span> <span class="pre">(2.5,</span> <span class="pre">1.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_OhD_G2p" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(G_{2}^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h^D\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_OhD_G2m">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_OhD_G2m</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(0.408248290463863,</span> <span class="pre">(2.5,</span> <span class="pre">2.5,</span> <span class="pre">-1)),</span> <span class="pre">(-0.9128709291752769,</span> <span class="pre">(2.5,</span> <span class="pre">-1.5,</span> <span class="pre">-1))],</span> <span class="pre">[(0.408248290463863,</span> <span class="pre">(2.5,</span> <span class="pre">-2.5,</span> <span class="pre">-1)),</span> <span class="pre">(-0.9128709291752769,</span> <span class="pre">(2.5,</span> <span class="pre">1.5,</span> <span class="pre">-1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_OhD_G2m" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(G_{2}^{-}\)</span> of <span class="math notranslate nohighlight">\(O_h^D\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_OhD_Hp">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_OhD_Hp</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(1.5,</span> <span class="pre">1.5,</span> <span class="pre">1))],</span> <span class="pre">[(1,</span> <span class="pre">(1.5,</span> <span class="pre">0.5,</span> <span class="pre">1))],</span> <span class="pre">[(1,</span> <span class="pre">(1.5,</span> <span class="pre">-0.5,</span> <span class="pre">1))],</span> <span class="pre">[(1,</span> <span class="pre">(1.5,</span> <span class="pre">-1.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_OhD_Hp" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(H^{+}\)</span> of <span class="math notranslate nohighlight">\(O_h^D\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_OhD_Hm">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_OhD_Hm</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(1.5,</span> <span class="pre">1.5,</span> <span class="pre">-1))],</span> <span class="pre">[(1,</span> <span class="pre">(1.5,</span> <span class="pre">0.5,</span> <span class="pre">-1))],</span> <span class="pre">[(1,</span> <span class="pre">(1.5,</span> <span class="pre">-0.5,</span> <span class="pre">-1))],</span> <span class="pre">[(1,</span> <span class="pre">(1.5,</span> <span class="pre">-1.5,</span> <span class="pre">-1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_OhD_Hm" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(H^{-}\)</span> of <span class="math notranslate nohighlight">\(O_h^D\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Dic4_G1">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Dic4_G1</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(0.5,</span> <span class="pre">0.5,</span> <span class="pre">1))],</span> <span class="pre">[(1,</span> <span class="pre">(0.5,</span> <span class="pre">-0.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Dic4_G1" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(G_{1}\)</span> of <span class="math notranslate nohighlight">\(\mathrm{Dic}_4\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Dic4_G2">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Dic4_G2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(0.408248290463863,</span> <span class="pre">(2.5,</span> <span class="pre">2.5,</span> <span class="pre">1)),</span> <span class="pre">(-0.9128709291752769,</span> <span class="pre">(2.5,</span> <span class="pre">-1.5,</span> <span class="pre">1))],</span> <span class="pre">[(0.408248290463863,</span> <span class="pre">(2.5,</span> <span class="pre">-2.5,</span> <span class="pre">1)),</span> <span class="pre">(-0.9128709291752769,</span> <span class="pre">(2.5,</span> <span class="pre">1.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Dic4_G2" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(G_{2}\)</span> of <span class="math notranslate nohighlight">\(\mathrm{Dic}_4\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Dic3_G">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Dic3_G</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(0.5,</span> <span class="pre">0.5,</span> <span class="pre">1))],</span> <span class="pre">[(1,</span> <span class="pre">(0.5,</span> <span class="pre">-0.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Dic3_G" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(G\)</span> of <span class="math notranslate nohighlight">\(\mathrm{Dic}_3\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Dic3_F1">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Dic3_F1</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(0.5,</span> <span class="pre">(1.5,</span> <span class="pre">1.5,</span> <span class="pre">1)),</span> <span class="pre">((0.08455098936288137+0.49279927982674443j),</span> <span class="pre">(1.5,</span> <span class="pre">0.5,</span> <span class="pre">1)),</span> <span class="pre">((0.4082482904638631+0.2886751345948129j),</span> <span class="pre">(1.5,</span> <span class="pre">-0.5,</span> <span class="pre">1)),</span> <span class="pre">((-0.35355339059327373-0.35355339059327373j),</span> <span class="pre">(1.5,</span> <span class="pre">-1.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Dic3_F1" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(F_{1}\)</span> of <span class="math notranslate nohighlight">\(\mathrm{Dic}_3\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Dic3_F2">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Dic3_F2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(0.5,</span> <span class="pre">(1.5,</span> <span class="pre">1.5,</span> <span class="pre">1)),</span> <span class="pre">((0.4927992798267444+0.08455098936288137j),</span> <span class="pre">(1.5,</span> <span class="pre">0.5,</span> <span class="pre">1)),</span> <span class="pre">((-0.4082482904638631+0.2886751345948129j),</span> <span class="pre">(1.5,</span> <span class="pre">-0.5,</span> <span class="pre">1)),</span> <span class="pre">((0.35355339059327373+0.35355339059327373j),</span> <span class="pre">(1.5,</span> <span class="pre">-1.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Dic3_F2" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(F_{2}\)</span> of <span class="math notranslate nohighlight">\(\mathrm{Dic}_3\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_Dic2_G">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_Dic2_G</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(0.5,</span> <span class="pre">0.5,</span> <span class="pre">1))],</span> <span class="pre">[(1,</span> <span class="pre">(0.5,</span> <span class="pre">-0.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_Dic2_G" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(G\)</span> of <span class="math notranslate nohighlight">\(\mathrm{Dic}_2\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C4R_F1">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C4R_F1</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(0.5,</span> <span class="pre">0.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C4R_F1" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(F_{1}\)</span> of <span class="math notranslate nohighlight">\(C_4^R\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C4R_F2">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C4R_F2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(0.5,</span> <span class="pre">-0.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C4R_F2" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(F_{2}\)</span> of <span class="math notranslate nohighlight">\(C_4^R\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C4P_F1">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C4P_F1</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(0.7071067811865475,</span> <span class="pre">(0.5,</span> <span class="pre">0.5,</span> <span class="pre">1)),</span> <span class="pre">((0.5-0.5j),</span> <span class="pre">(0.5,</span> <span class="pre">-0.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C4P_F1" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(F_{1}\)</span> of <span class="math notranslate nohighlight">\(C_4^P\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C4P_F2">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C4P_F2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(0.7071067811865475,</span> <span class="pre">(0.5,</span> <span class="pre">0.5,</span> <span class="pre">1)),</span> <span class="pre">((-0.5+0.5j),</span> <span class="pre">(0.5,</span> <span class="pre">-0.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C4P_F2" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(F_{2}\)</span> of <span class="math notranslate nohighlight">\(C_4^P\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_C1D_F">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_C1D_F</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(0.5,</span> <span class="pre">0.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_C1D_F" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for irrep <span class="math notranslate nohighlight">\(F\)</span> of <span class="math notranslate nohighlight">\(C_1^D\)</span>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mhi.basis_functions.basis_nucleon">
<span class="sig-prename descclassname"><span class="pre">mhi.basis_functions.</span></span><span class="sig-name descname"><span class="pre">basis_nucleon</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">[[(1,</span> <span class="pre">(0.5,</span> <span class="pre">0.5,</span> <span class="pre">1))],</span> <span class="pre">[(1,</span> <span class="pre">(0.5,</span> <span class="pre">-0.5,</span> <span class="pre">1))]]</span></em><a class="headerlink" href="#mhi.basis_functions.basis_nucleon" title="Link to this definition">#</a></dt>
<dd><p>Basis spinors for the nucleon.</p>
</dd></dl>

</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="index.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Overview</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mhi.mhi">Main module</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.mhi"><code class="docutils literal notranslate"><span class="pre">mhi()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.WeightedPermutation"><code class="docutils literal notranslate"><span class="pre">WeightedPermutation</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.Isomorphism"><code class="docutils literal notranslate"><span class="pre">Isomorphism</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.SpinShellTuple"><code class="docutils literal notranslate"><span class="pre">SpinShellTuple</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.levi_civita"><code class="docutils literal notranslate"><span class="pre">levi_civita()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.unique_permutations"><code class="docutils literal notranslate"><span class="pre">unique_permutations()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.symmetrize"><code class="docutils literal notranslate"><span class="pre">symmetrize()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.tensor_product"><code class="docutils literal notranslate"><span class="pre">tensor_product()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.tensor_nfold"><code class="docutils literal notranslate"><span class="pre">tensor_nfold()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.decompose"><code class="docutils literal notranslate"><span class="pre">decompose()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.compute_polarization"><code class="docutils literal notranslate"><span class="pre">compute_polarization()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.contract_across"><code class="docutils literal notranslate"><span class="pre">contract_across()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.compute_restitution"><code class="docutils literal notranslate"><span class="pre">compute_restitution()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.polarize"><code class="docutils literal notranslate"><span class="pre">polarize()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.transform"><code class="docutils literal notranslate"><span class="pre">transform()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.tensor_inner"><code class="docutils literal notranslate"><span class="pre">tensor_inner()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_tensor_product_space"><code class="docutils literal notranslate"><span class="pre">make_tensor_product_space()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.DiracPauli"><code class="docutils literal notranslate"><span class="pre">DiracPauli</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.DiracPauli.rotation_vec"><code class="docutils literal notranslate"><span class="pre">DiracPauli.rotation_vec()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.DiracPauli.rotation"><code class="docutils literal notranslate"><span class="pre">DiracPauli.rotation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.get_nprod"><code class="docutils literal notranslate"><span class="pre">get_nprod()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_spinor_array"><code class="docutils literal notranslate"><span class="pre">make_spinor_array()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_oh"><code class="docutils literal notranslate"><span class="pre">make_oh()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.rotation"><code class="docutils literal notranslate"><span class="pre">rotation()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.rotation_vec"><code class="docutils literal notranslate"><span class="pre">rotation_vec()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_ohd"><code class="docutils literal notranslate"><span class="pre">make_ohd()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_spinorial_little_group"><code class="docutils literal notranslate"><span class="pre">make_spinorial_little_group()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_stabilizer"><code class="docutils literal notranslate"><span class="pre">make_stabilizer()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_canonical_stabilizer"><code class="docutils literal notranslate"><span class="pre">make_canonical_stabilizer()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.identify_stabilizer"><code class="docutils literal notranslate"><span class="pre">identify_stabilizer()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_little_and_stabilizer"><code class="docutils literal notranslate"><span class="pre">make_little_and_stabilizer()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.conjugate"><code class="docutils literal notranslate"><span class="pre">conjugate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.conjugate_group"><code class="docutils literal notranslate"><span class="pre">conjugate_group()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.find_subgroup_isomorphism"><code class="docutils literal notranslate"><span class="pre">find_subgroup_isomorphism()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.apply_isomorphism"><code class="docutils literal notranslate"><span class="pre">apply_isomorphism()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.force_hash"><code class="docutils literal notranslate"><span class="pre">force_hash()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.HashableArray"><code class="docutils literal notranslate"><span class="pre">HashableArray</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.MomentumSpinOrbitElement"><code class="docutils literal notranslate"><span class="pre">MomentumSpinOrbitElement</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_momentum_orbit"><code class="docutils literal notranslate"><span class="pre">make_momentum_orbit()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_momentum_spin_orbit"><code class="docutils literal notranslate"><span class="pre">make_momentum_spin_orbit()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.parity"><code class="docutils literal notranslate"><span class="pre">parity()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.partition"><code class="docutils literal notranslate"><span class="pre">partition()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.recombine"><code class="docutils literal notranslate"><span class="pre">recombine()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_exchange_projector"><code class="docutils literal notranslate"><span class="pre">make_exchange_projector()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_exchange_projector_identical"><code class="docutils literal notranslate"><span class="pre">make_exchange_projector_identical()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_internal_symmetry_projector"><code class="docutils literal notranslate"><span class="pre">make_internal_symmetry_projector()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.multiply_perms"><code class="docutils literal notranslate"><span class="pre">multiply_perms()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.invert_perm"><code class="docutils literal notranslate"><span class="pre">invert_perm()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.compose_permutation_algebra_elements"><code class="docutils literal notranslate"><span class="pre">compose_permutation_algebra_elements()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.algebra_elements_are_close"><code class="docutils literal notranslate"><span class="pre">algebra_elements_are_close()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.is_valid_tableau"><code class="docutils literal notranslate"><span class="pre">is_valid_tableau()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.transpose_tableau"><code class="docutils literal notranslate"><span class="pre">transpose_tableau()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.symmetrizer"><code class="docutils literal notranslate"><span class="pre">symmetrizer()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_young_projector"><code class="docutils literal notranslate"><span class="pre">make_young_projector()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_momentum_orbit_rep_matrix"><code class="docutils literal notranslate"><span class="pre">make_momentum_orbit_rep_matrix()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_momentum_orbit_rep"><code class="docutils literal notranslate"><span class="pre">make_momentum_orbit_rep()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_momentum_spin_rep"><code class="docutils literal notranslate"><span class="pre">make_momentum_spin_rep()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_irrep_matrix"><code class="docutils literal notranslate"><span class="pre">make_irrep_matrix()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_irrep"><code class="docutils literal notranslate"><span class="pre">make_irrep()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_irrep_matrix_spinor"><code class="docutils literal notranslate"><span class="pre">make_irrep_matrix_spinor()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_irrep_spinor"><code class="docutils literal notranslate"><span class="pre">make_irrep_spinor()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_irrep_from_group"><code class="docutils literal notranslate"><span class="pre">make_irrep_from_group()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_irrep_from_groupD"><code class="docutils literal notranslate"><span class="pre">make_irrep_from_groupD()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.orth"><code class="docutils literal notranslate"><span class="pre">orth()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.project"><code class="docutils literal notranslate"><span class="pre">project()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.apply_schur"><code class="docutils literal notranslate"><span class="pre">apply_schur()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.rephase"><code class="docutils literal notranslate"><span class="pre">rephase()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.load_particle_info"><code class="docutils literal notranslate"><span class="pre">load_particle_info()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_pseudoscalar_irrep"><code class="docutils literal notranslate"><span class="pre">make_pseudoscalar_irrep()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_spin_half_irrep"><code class="docutils literal notranslate"><span class="pre">make_spin_half_irrep()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.make_Dspin"><code class="docutils literal notranslate"><span class="pre">make_Dspin()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.identify_spin_dim"><code class="docutils literal notranslate"><span class="pre">identify_spin_dim()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.IrrepDecomposition"><code class="docutils literal notranslate"><span class="pre">IrrepDecomposition</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.IrrepDecomposition.format"><code class="docutils literal notranslate"><span class="pre">IrrepDecomposition.format()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.IrrepDecomposition.little_name"><code class="docutils literal notranslate"><span class="pre">IrrepDecomposition.little_name()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.IrrepDecomposition.stab_name"><code class="docutils literal notranslate"><span class="pre">IrrepDecomposition.stab_name()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.test_stabilizer"><code class="docutils literal notranslate"><span class="pre">test_stabilizer()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.anticommutator"><code class="docutils literal notranslate"><span class="pre">anticommutator()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.commutator"><code class="docutils literal notranslate"><span class="pre">commutator()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.test_clifford"><code class="docutils literal notranslate"><span class="pre">test_clifford()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.test_gamma5"><code class="docutils literal notranslate"><span class="pre">test_gamma5()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.test_row_orthogonality"><code class="docutils literal notranslate"><span class="pre">test_row_orthogonality()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.count_degeneracy"><code class="docutils literal notranslate"><span class="pre">count_degeneracy()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.test_degenerate_orthogonality"><code class="docutils literal notranslate"><span class="pre">test_degenerate_orthogonality()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.test_block_diagonalization"><code class="docutils literal notranslate"><span class="pre">test_block_diagonalization()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.write_hdf5"><code class="docutils literal notranslate"><span class="pre">write_hdf5()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.mhi.read_hdf5"><code class="docutils literal notranslate"><span class="pre">read_hdf5()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mhi.basis_functions">Basis functions module</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.SpinorTuple"><code class="docutils literal notranslate"><span class="pre">SpinorTuple</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Oh_A1p"><code class="docutils literal notranslate"><span class="pre">basis_Oh_A1p</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Oh_A1m"><code class="docutils literal notranslate"><span class="pre">basis_Oh_A1m</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Oh_A2p"><code class="docutils literal notranslate"><span class="pre">basis_Oh_A2p</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Oh_A2m"><code class="docutils literal notranslate"><span class="pre">basis_Oh_A2m</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Oh_Ep"><code class="docutils literal notranslate"><span class="pre">basis_Oh_Ep</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Oh_Em"><code class="docutils literal notranslate"><span class="pre">basis_Oh_Em</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Oh_T1m"><code class="docutils literal notranslate"><span class="pre">basis_Oh_T1m</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Oh_T1p"><code class="docutils literal notranslate"><span class="pre">basis_Oh_T1p</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Oh_T2m"><code class="docutils literal notranslate"><span class="pre">basis_Oh_T2m</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Oh_T2p"><code class="docutils literal notranslate"><span class="pre">basis_Oh_T2p</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C4v_A1"><code class="docutils literal notranslate"><span class="pre">basis_C4v_A1</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C4v_A2"><code class="docutils literal notranslate"><span class="pre">basis_C4v_A2</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C4v_B1"><code class="docutils literal notranslate"><span class="pre">basis_C4v_B1</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C4v_B2"><code class="docutils literal notranslate"><span class="pre">basis_C4v_B2</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C4v_E"><code class="docutils literal notranslate"><span class="pre">basis_C4v_E</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C3v_A1"><code class="docutils literal notranslate"><span class="pre">basis_C3v_A1</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C3v_A2"><code class="docutils literal notranslate"><span class="pre">basis_C3v_A2</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C3v_E"><code class="docutils literal notranslate"><span class="pre">basis_C3v_E</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C2v_A1"><code class="docutils literal notranslate"><span class="pre">basis_C2v_A1</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C2v_A2"><code class="docutils literal notranslate"><span class="pre">basis_C2v_A2</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C2v_B1"><code class="docutils literal notranslate"><span class="pre">basis_C2v_B1</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C2v_B2"><code class="docutils literal notranslate"><span class="pre">basis_C2v_B2</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C2R_A"><code class="docutils literal notranslate"><span class="pre">basis_C2R_A</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C2R_B"><code class="docutils literal notranslate"><span class="pre">basis_C2R_B</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C2P_A"><code class="docutils literal notranslate"><span class="pre">basis_C2P_A</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C2P_B"><code class="docutils literal notranslate"><span class="pre">basis_C2P_B</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C1_A"><code class="docutils literal notranslate"><span class="pre">basis_C1_A</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_OhD_G1p"><code class="docutils literal notranslate"><span class="pre">basis_OhD_G1p</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_OhD_G1m"><code class="docutils literal notranslate"><span class="pre">basis_OhD_G1m</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_OhD_G2p"><code class="docutils literal notranslate"><span class="pre">basis_OhD_G2p</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_OhD_G2m"><code class="docutils literal notranslate"><span class="pre">basis_OhD_G2m</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_OhD_Hp"><code class="docutils literal notranslate"><span class="pre">basis_OhD_Hp</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_OhD_Hm"><code class="docutils literal notranslate"><span class="pre">basis_OhD_Hm</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Dic4_G1"><code class="docutils literal notranslate"><span class="pre">basis_Dic4_G1</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Dic4_G2"><code class="docutils literal notranslate"><span class="pre">basis_Dic4_G2</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Dic3_G"><code class="docutils literal notranslate"><span class="pre">basis_Dic3_G</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Dic3_F1"><code class="docutils literal notranslate"><span class="pre">basis_Dic3_F1</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Dic3_F2"><code class="docutils literal notranslate"><span class="pre">basis_Dic3_F2</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_Dic2_G"><code class="docutils literal notranslate"><span class="pre">basis_Dic2_G</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C4R_F1"><code class="docutils literal notranslate"><span class="pre">basis_C4R_F1</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C4R_F2"><code class="docutils literal notranslate"><span class="pre">basis_C4R_F2</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C4P_F1"><code class="docutils literal notranslate"><span class="pre">basis_C4P_F1</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C4P_F2"><code class="docutils literal notranslate"><span class="pre">basis_C4P_F2</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_C1D_F"><code class="docutils literal notranslate"><span class="pre">basis_C1D_F</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mhi.basis_functions.basis_nucleon"><code class="docutils literal notranslate"><span class="pre">basis_nucleon</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, William Detmold, William I. Jay, Gurtej Kanwar, Phiala E. Shanahan, and Michael L. Wagman.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.2.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>