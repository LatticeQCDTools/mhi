
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mhi.mhi &#8212; Multi-Hadron Interpolators</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/mhi/mhi';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Multi-Hadron Interpolators</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../code.html">
                        Package documentation
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../code.html">
                        Package documentation
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">mhi.mhi</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for mhi.mhi</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">MHI -- &quot;Multi-Hadron Interpolators&quot;</span>

<span class="sd">Module for constructing block-diagonalization / change-of-basis matrices to map</span>
<span class="sd">products of N local plane-wave operators into irreps of the cubic group.</span>
<span class="sd">Includes appropriate generalizations for spin and internal symmetries.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">sha256</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">basis_functions</span>


<span class="c1">###############</span>
<span class="c1"># Main driver #</span>
<span class="c1">###############</span>

<div class="viewcode-block" id="mhi">
<a class="viewcode-back" href="../../code.html#mhi.mhi.mhi">[docs]</a>
<span class="k">def</span> <span class="nf">mhi</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">spin_irreps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">internal_symmetry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    General-purpose driver function for construction of change-of-basis /</span>
<span class="sd">    block-diagonalization matrices which project linear combinations of plane-</span>
<span class="sd">    wave states onto irreps of the cubic group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    momenta : ``(nparticles, 3)`` or ``(3, )`` array_like</span>
<span class="sd">        The ordered momenta.</span>
<span class="sd">    particle_names : array_like</span>
<span class="sd">        The particle names, e.g., [&#39;n&#39;, &#39;p&#39;].</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Whether or not to print extra diagnostic information.</span>
<span class="sd">    return_Dmm : bool</span>
<span class="sd">        Whether or not to return the momentum-(spin) representation matrices.</span>
<span class="sd">    internal_symmetry : list of :class:`WeightedPermutation`</span>
<span class="sd">        The exchange group projector defined in the group algebra.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : :class:`IrrepDecomposition`</span>
<span class="sd">        object containing the results of the irrep decomposition.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm is as follows:</span>
<span class="sd">      - Compute the little group of the total momentum</span>
<span class="sd">      - Compute irrep matrices of the little group, :math:`D_{\mu\nu}(R)`</span>
<span class="sd">      - Compute the momentum(-spin) representation matrices, :math:`D_{mm&#39;}(R)`</span>
<span class="sd">      - Apply exchange-group projection, giving :math:`\hat{D}(R) = P D(R) P`</span>
<span class="sd">      - Apply Schur&#39;s algorithm and transition operators to construct the</span>
<span class="sd">        block-diagonalization matrices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">spin_irreps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">spin_irreps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spin_irreps</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">momenta</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incomensurate momenta and spin irreps specified.&quot;</span><span class="p">)</span>

    <span class="c1"># 1. Compute the little group of the total momentum</span>
    <span class="n">little</span><span class="p">,</span> <span class="n">stab</span> <span class="o">=</span> <span class="n">make_little_and_stabilizer</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">make_oh</span><span class="p">())</span>
    <span class="n">little_name</span> <span class="o">=</span> <span class="n">identify_stabilizer</span><span class="p">(</span><span class="n">little</span><span class="p">)</span>
    <span class="n">stab_name</span> <span class="o">=</span> <span class="n">identify_stabilizer</span><span class="p">(</span><span class="n">stab</span><span class="p">)</span>
    <span class="n">little_canonical</span> <span class="o">=</span> <span class="n">make_canonical_stabilizer</span><span class="p">(</span><span class="n">little_name</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">make_oh</span><span class="p">())</span>
    <span class="n">isomorphism</span> <span class="o">=</span> <span class="n">find_subgroup_isomorphism</span><span class="p">(</span><span class="n">make_oh</span><span class="p">(),</span> <span class="n">little_canonical</span> <span class="p">,</span> <span class="n">little</span><span class="p">)</span>
    <span class="n">little</span> <span class="o">=</span> <span class="n">little</span><span class="p">[</span><span class="n">isomorphism</span><span class="o">.</span><span class="n">perm</span><span class="p">]</span>  <span class="c1"># Rotate to conventional orientation</span>
    <span class="n">little_double</span> <span class="o">=</span> <span class="n">make_spinorial_little_group</span><span class="p">(</span><span class="n">little</span><span class="p">)</span>

    <span class="c1"># 2. Compute the irrep matrics of the little group</span>
    <span class="k">if</span> <span class="n">spin_irreps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Distinguishable spin-zero particles. Single-cover irrep matrics suffice.</span>
        <span class="n">Dmumu</span> <span class="o">=</span> <span class="n">make_irrep_from_group</span><span class="p">(</span><span class="n">little_canonical</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Dmumu</span> <span class="o">=</span> <span class="n">make_irrep_from_groupD</span><span class="p">(</span><span class="n">little_canonical</span><span class="p">)</span>

    <span class="c1"># 3. Compute momentum(-spin) representation matrices</span>
    <span class="n">orbit</span> <span class="o">=</span> <span class="n">make_momentum_orbit</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">internal_symmetry</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spin_irreps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spin_dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">momenta</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spin_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">identify_spin_dim</span><span class="p">(</span><span class="n">irrep</span><span class="p">)</span> <span class="k">for</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="n">spin_irreps</span><span class="p">]</span>
    <span class="n">orbit_momspin</span> <span class="o">=</span> <span class="n">make_momentum_spin_orbit</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">spin_dims</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">internal_symmetry</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Size of extended orbit: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit_momspin</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit_momspin</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">((</span>
            <span class="s2">&quot;Warning: detailed optimization efforts have not been made &quot;</span>
            <span class="s2">&quot;in the reference implementation.</span><span class="se">\n</span><span class="s2">Additional optimization may be &quot;</span>
            <span class="s2">&quot;required for calculations with large momentum-spin orbits.&quot;</span>
        <span class="p">))</span>
    <span class="n">Dmm</span> <span class="o">=</span> <span class="n">make_momentum_orbit_rep</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">little</span><span class="p">)</span>
    <span class="n">Dspin</span> <span class="o">=</span> <span class="n">make_Dspin</span><span class="p">(</span><span class="n">spin_irreps</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">little_double</span><span class="p">)</span>
    <span class="n">Dmm_momspin</span> <span class="o">=</span> <span class="n">make_momentum_spin_rep</span><span class="p">(</span><span class="n">Dmm</span><span class="p">,</span> <span class="o">*</span><span class="n">Dspin</span><span class="p">)</span>

    <span class="c1"># 4. Compute and apply projection from the internal symmetry group</span>
    <span class="k">if</span> <span class="n">internal_symmetry</span><span class="p">:</span>
        <span class="c1"># Naively, the projector applied to the Dmm should be proj @ Dmm(R) @ proj.</span>
        <span class="c1"># However, the projector is idempotent, and the permutations commute</span>
        <span class="c1"># with rotations. Therefore, it suffices to compute Dmm(R) @ proj.</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="n">make_internal_symmetry_projector</span><span class="p">(</span><span class="n">orbit_momspin</span><span class="p">,</span> <span class="n">internal_symmetry</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">proj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Dmm_momspin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Dmm_momspin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ajk,kl&quot;</span><span class="p">,</span> <span class="n">Dmm_momspin</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>

    <span class="c1"># 5. Apply Schur&#39;s lemma</span>
    <span class="k">if</span> <span class="n">Dmm_momspin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">transition_operators</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">transition_operators</span> <span class="o">=</span> <span class="n">apply_schur</span><span class="p">(</span><span class="n">Dmm_momspin</span><span class="p">,</span> <span class="n">Dmumu</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Decomposition vanishes for specified inputs.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">IrrepDecomposition</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">orbit_momspin</span><span class="p">,</span> <span class="n">Dmm_momspin</span><span class="p">,</span> <span class="n">Dmumu</span><span class="p">,</span> <span class="n">little_name</span><span class="p">,</span> <span class="n">stab_name</span><span class="p">,</span> <span class="n">transition_operators</span><span class="p">)</span></div>



<span class="c1">####################</span>
<span class="c1"># Basic data types #</span>
<span class="c1">####################</span>

<div class="viewcode-block" id="WeightedPermutation">
<a class="viewcode-back" href="../../code.html#mhi.mhi.WeightedPermutation">[docs]</a>
<span class="k">class</span> <span class="nc">WeightedPermutation</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;WeightedPermutation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="s1">&#39;perm&#39;</span><span class="p">])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A complex scalar weight times a permutation group element.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    weight : complex or float</span>
<span class="sd">        Scalar weight multiplying the permutation.</span>
<span class="sd">    perm : ``(n,)`` ndarray</span>
<span class="sd">        Permutation expressed as an array.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="Isomorphism">
<a class="viewcode-back" href="../../code.html#mhi.mhi.Isomorphism">[docs]</a>
<span class="k">class</span> <span class="nc">Isomorphism</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Isomorphism&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;perm&#39;</span><span class="p">])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The group element and permutation specifying a subgroup isomorphism.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    g : ``(n, n)`` ndarray</span>
<span class="sd">        Group element used to conjugate the subgroup as</span>
<span class="sd">        :math:`g \cdot H \cdot g^{-1}`</span>
<span class="sd">    perm : ``(|H|,)`` ndarray</span>
<span class="sd">        Permutation p mapping from conjugated elements to target subgroup as</span>
<span class="sd">        :math:`H&#39; = g \cdot H \cdot g^{-1}[p]`</span>
<span class="sd">    &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="SpinShellTuple">
<a class="viewcode-back" href="../../code.html#mhi.mhi.SpinShellTuple">[docs]</a>
<span class="k">class</span> <span class="nc">SpinShellTuple</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;SpinShellTuple&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;momenta&#39;</span><span class="p">,</span> <span class="s1">&#39;spins&#39;</span><span class="p">])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pairing of momenta and spins making up an orbit with non-zero spins.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    momenta : ``(norbit, nmomenta, 3)`` ndarray</span>
<span class="sd">        List of momentum lists in the orbit.</span>
<span class="sd">    spins : ``(norbit, nspin)`` ndarray</span>
<span class="sd">        List of spin configurations in the orbit.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<span class="c1">####################</span>
<span class="c1"># Tensor utilities #</span>
<span class="c1">####################</span>

<div class="viewcode-block" id="levi_civita">
<a class="viewcode-back" href="../../code.html#mhi.mhi.levi_civita">[docs]</a>
<span class="k">def</span> <span class="nf">levi_civita</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The totally antisymmetric Levi-Civita tensor in arbitrary dimensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : int</span>
<span class="sd">        The number of dimensions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        The Levi-Civita tensor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Implementation from StackOverflow user JGibs:</span>
<span class="sd">    https://stackoverflow.com/questions/59740966/levi-civita-tensor-in-numpy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">))):</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">x</span><span class="p">):</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">arr</span></div>



<div class="viewcode-block" id="unique_permutations">
<a class="viewcode-back" href="../../code.html#mhi.mhi.unique_permutations">[docs]</a>
<span class="k">def</span> <span class="nf">unique_permutations</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Yield only unique permutations of seq in an efficient way.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seq: array_like</span>
<span class="sd">        The elements to be permuted</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    seq: array_like</span>
<span class="sd">        The permuated sequences</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; for perm in unique_permutations([1, 1, 2]):</span>
<span class="sd">    &gt;&gt;&gt;     print(perm)</span>
<span class="sd">    [1, 1, 2]</span>
<span class="sd">    [1, 2, 1]</span>
<span class="sd">    [2, 1, 1]</span>
<span class="sd">    &gt;&gt;&gt; for perm in unique_permutations([&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]):</span>
<span class="sd">    &gt;&gt;&gt;     print(perm)</span>
<span class="sd">    [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]</span>
<span class="sd">    [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">    [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;]</span>
<span class="sd">    [&#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">    [&#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;]</span>
<span class="sd">    [&#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;]</span>
<span class="sd">    [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A python implementation of Knuth&#39;s &quot;Algorithm L&quot;, also known from the</span>
<span class="sd">    std::next_permutation function of C++, and as the permutation algorithm</span>
<span class="sd">    of Narayana Pandita.</span>

<span class="sd">    Code taken from a post by StackOverflow user Lauritz V. Thaulow:</span>
<span class="sd">    https://stackoverflow.com/questions/12836385/how-can-i-interleave-or-create-unique-permutations-of-two-strings-without-recur/12837695#12837695</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Precalculate the indices we&#39;ll be iterating over for speed</span>
    <span class="n">i_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">k_indices</span> <span class="o">=</span> <span class="n">i_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># The algorithm specifies to start with a sorted version</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">seq</span>

        <span class="c1"># Working backwards from the last-but-one index,           k</span>
        <span class="c1"># we find the index of the first decrease in value.  0 0 1 0 1 1 1 0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k_indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">seq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Introducing the slightly unknown python for-else syntax:</span>
            <span class="c1"># else is executed only if the break statement was never reached.</span>
            <span class="c1"># If this is the case, seq is weakly decreasing, and we&#39;re done.</span>
            <span class="k">return</span>

        <span class="c1"># Get item from sequence only once, for speed</span>
        <span class="n">k_val</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># Working backwards starting with the last item,           k     i</span>
        <span class="c1"># find the first one greater than the one at k       0 0 1 0 1 1 1 0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k_val</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">break</span>

        <span class="c1"># Swap them in the most efficient way</span>
        <span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>                <span class="c1">#       k     i</span>
                                                           <span class="c1"># 0 0 1 1 1 1 0 0</span>

        <span class="c1"># Reverse the part after but not                           k</span>
        <span class="c1"># including k, also efficiently.                     0 0 1 1 0 0 1 1</span>
        <span class="n">seq</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">k</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="symmetrize">
<a class="viewcode-back" href="../../code.html#mhi.mhi.symmetrize">[docs]</a>
<span class="k">def</span> <span class="nf">symmetrize</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the completely symmetrized version of the input array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        A tensor of arbitrary rank.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr_sym : ndarray</span>
<span class="sd">        The completely symmetrized version of the input tensor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In index notation symmetrization is the map which sends</span>
<span class="sd">    :math:`T_{ij...n} \to T_{(ij...n)}`,</span>
<span class="sd">    where parantheses denote symmetrization.</span>
<span class="sd">    For instance, the symmetrization of a three-index tensor</span>
<span class="sd">    :math:`T_{ijk}`</span>
<span class="sd">    is</span>
<span class="sd">    :math:`T_{(ijk)} = \tfrac{1}{6}(T_{ijk} + T_{ikj} + T_{jik} + T_{jki} + T_{kij} + T_{kji})`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="c1"># Run over unique index combinations</span>
    <span class="c1"># For instance, {(1,0,0), (0,1,0), (0,0,1)} should be identified</span>
    <span class="n">arr_sym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">r</span><span class="o">=</span><span class="n">rank</span><span class="p">):</span>
        <span class="c1"># Run over permuations of a given index combination</span>
        <span class="c1"># For instance, (1,0,0) --&gt; [(1,0,0), (0,1,0), (0,0,1)]</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">unique_permutations</span><span class="p">(</span><span class="n">idxs</span><span class="p">)]</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">:</span>
            <span class="n">arr_sym</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">sym</span>
    <span class="k">return</span> <span class="n">arr_sym</span></div>



<div class="viewcode-block" id="tensor_product">
<a class="viewcode-back" href="../../code.html#mhi.mhi.tensor_product">[docs]</a>
<span class="k">def</span> <span class="nf">tensor_product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the tensor product between tensors a and b.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array_like</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor : array_like</span>
<span class="sd">        The tensor product of arrays `a` and `b`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In index notation, this fuction computes the output tensor T defined by</span>
<span class="sd">    :math:`T_{ij \dots k rs \dots t} = a_{ij \dots k} b_{rs \dots t}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="tensor_nfold">
<a class="viewcode-back" href="../../code.html#mhi.mhi.tensor_nfold">[docs]</a>
<span class="k">def</span> <span class="nf">tensor_nfold</span><span class="p">(</span><span class="o">*</span><span class="n">tensors</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the n-fold tensor product between all the tensors in a list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensors : (variable number of) ndarray</span>
<span class="sd">        The input tensors for the product.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor : ndarray</span>
<span class="sd">        The product of all the tensors.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Suppose the input tensors are</span>
<span class="sd">    :math:`\{a_i, b_{jk}, c_{lmn}\}`.</span>
<span class="sd">    This function computes the output tensor T defined by</span>
<span class="sd">    :math:`T_{ijklmn} = a_i b_{jk} c_{lmn}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">tensor_product</span><span class="p">,</span> <span class="n">tensors</span><span class="p">)</span></div>



<div class="viewcode-block" id="decompose">
<a class="viewcode-back" href="../../code.html#mhi.mhi.decompose">[docs]</a>
<span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="n">monomial</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decomposes a sympy monomial of the form</span>
<span class="sd">    ``c * x**nx * y**ny * z**nz``</span>
<span class="sd">    into a coefficient `c` and a triplet of exponents ``(nx, ny, nz)``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    monomial : sympy.core.mul.Mul</span>
<span class="sd">        A monomial in the variables {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (coeff, exponents) : (complex, tuple)</span>
<span class="sd">        The coefficient and exponents (nx, ny, nz) of the monomial</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">monomial</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">monomial</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
    <span class="n">nz</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">monomial</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">monomial</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="n">nx</span> <span class="o">*</span> <span class="n">Y</span><span class="o">**</span><span class="n">ny</span> <span class="o">*</span> <span class="n">Z</span><span class="o">**</span><span class="n">nz</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">coeff</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span></div>



<div class="viewcode-block" id="compute_polarization">
<a class="viewcode-back" href="../../code.html#mhi.mhi.compute_polarization">[docs]</a>
<span class="k">def</span> <span class="nf">compute_polarization</span><span class="p">(</span><span class="n">monomial</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the polarization tensor of a given monomial.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    monomial : sympy.core.mul.Mul</span>
<span class="sd">        A monomial in the variables {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    polarization_tensor : ndarray</span>
<span class="sd">        The polarization, a totally symmetric tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coeff</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span> <span class="o">=</span> <span class="n">decompose</span><span class="p">(</span><span class="n">monomial</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">nx</span><span class="o">*</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">ny</span><span class="o">*</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nz</span><span class="o">*</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">symmetrize</span><span class="p">(</span><span class="n">tensor_nfold</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span></div>



<div class="viewcode-block" id="contract_across">
<a class="viewcode-back" href="../../code.html#mhi.mhi.contract_across">[docs]</a>
<span class="k">def</span> <span class="nf">contract_across</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Conctract a vector full across all the free indices, yielding a scalar.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Tensor of generic rank</span>
<span class="sd">    vec : array_like</span>
<span class="sd">        The vector to contract against all the free indices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar : float or complex</span>
<span class="sd">        The product c = vec[i]*vec[j]*...*vec[n]*arr[i,j,...,n]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">item</span><span class="p">()</span></div>



<div class="viewcode-block" id="compute_restitution">
<a class="viewcode-back" href="../../code.html#mhi.mhi.compute_restitution">[docs]</a>
<span class="k">def</span> <span class="nf">compute_restitution</span><span class="p">(</span><span class="n">polarization</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the monomial restitution of a polarization tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polarization : array_like</span>
<span class="sd">        The (completely symmetric) polarization tensor</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    restitution : monomial (sympy.core.mul.Mul)</span>
<span class="sd">        The monomial resulting from contracting the vector [x,y,z] across all</span>
<span class="sd">        the free indices of the polarization tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">contract_across</span><span class="p">(</span><span class="n">polarization</span><span class="p">,</span> <span class="n">vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)))</span></div>



<div class="viewcode-block" id="polarize">
<a class="viewcode-back" href="../../code.html#mhi.mhi.polarize">[docs]</a>
<span class="k">def</span> <span class="nf">polarize</span><span class="p">(</span><span class="n">fcn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the polarization tensor associated with a basis function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fcn : sympy basis function</span>
<span class="sd">        The basis function, a sum of monomials in {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;}.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        The polarization tensor of rank d, where d is the degree of the</span>
<span class="sd">        monomials within the basis function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fcn</span> <span class="o">=</span> <span class="n">fcn</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Mul</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Pow</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Add</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad type&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">fcn</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Mul</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Pow</span><span class="p">)):</span>
        <span class="c1"># fcn is already a monomial</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">compute_polarization</span><span class="p">(</span><span class="n">fcn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># fcn is generically a polynomial, so run through monomials in the sum</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">summands</span> <span class="o">=</span> <span class="n">fcn</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">args</span>
        <span class="k">for</span> <span class="n">monomial</span> <span class="ow">in</span> <span class="n">summands</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">compute_polarization</span><span class="p">(</span><span class="n">monomial</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arr</span></div>



<div class="viewcode-block" id="transform">
<a class="viewcode-back" href="../../code.html#mhi.mhi.transform">[docs]</a>
<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">group_element</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the &quot;rotation&quot; transformation of a tensor of arbitrary rank,</span>
<span class="sd">    A[a,b,...,c] --&gt; R[a,x] R[b,y] ... R[c,z] A[x,y,...,z].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ``(M, M, ..., M)`` array_like</span>
<span class="sd">        The tensor to transform.</span>
<span class="sd">    group_element : ``(M, M)`` array_like</span>
<span class="sd">        The group element applying the transformation.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Whether to print the indices used in Einstein summation notation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr_transformed : ndarray</span>
<span class="sd">        The transformed tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Assemble indices Einstein summation notation.</span>
    <span class="c1"># For example, for transforming a rank-3 tensor:</span>
    <span class="c1"># R[ad]*R[be]*R[cf]*arr[def] --&gt; ad,be,cf,def</span>
    <span class="k">if</span> <span class="mi">2</span><span class="o">*</span><span class="n">rank</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Rank too large for current implementation.&quot;</span><span class="p">)</span>
    <span class="n">idxs1</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">[:</span><span class="n">rank</span><span class="p">]</span>
    <span class="n">idxs2</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">[</span><span class="n">rank</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">rank</span><span class="p">]</span>
    <span class="n">subscripts</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
        <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i1</span><span class="si">}{</span><span class="n">i2</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idxs1</span><span class="p">,</span> <span class="n">idxs2</span><span class="p">)]),</span>
        <span class="n">idxs2</span>
    <span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">subscripts</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">rank</span> <span class="o">*</span> <span class="p">[</span><span class="n">group_element</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">arr</span><span class="p">]</span>  <span class="c1"># einsum eats a list of tensors</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">subscripts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="tensor_inner">
<a class="viewcode-back" href="../../code.html#mhi.mhi.tensor_inner">[docs]</a>
<span class="k">def</span> <span class="nf">tensor_inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the inner product between two tensors a[i,j,...,k]*b[i,j,...,k].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ``(M, M, ... , M)`` array_like</span>
<span class="sd">    b : ``(M, M, ... , M)`` array_like</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c : float or complex</span>
<span class="sd">        The result of the inner product across all free indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span><span class="p">,</span> <span class="n">rank2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">!=</span> <span class="n">rank2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incommensurate ranks&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">rank2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Rank too large for current implementation.&quot;</span><span class="p">)</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">[:</span><span class="n">rank</span><span class="p">]</span>
    <span class="n">subscripts</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">idxs</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">idxs</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">subscripts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">subscripts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="make_tensor_product_space">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_tensor_product_space">[docs]</a>
<span class="k">def</span> <span class="nf">make_tensor_product_space</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a tensor product space with the specified dimensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dims : list</span>
<span class="sd">        Integers specifying the dimensions</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor_product_space : ndarray</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    These spaces arise naturally in the construction of combined &quot;momentum-</span>
<span class="sd">    spin&quot; orbits below. For the portion of the orbit associated with spin,</span>
<span class="sd">    it&#39;s assumed that the spin has already been decomposed into irreps of</span>
<span class="sd">    known dimensions. By definition of the irrep space, group transformation</span>
<span class="sd">    simply permute the basis elements of the irrep space.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = make_tensor_product_space([1,2,3])</span>
<span class="sd">    &gt;&gt;&gt; print(arr.shape)</span>
<span class="sd">    (6, 3)</span>
<span class="sd">    &gt;&gt;&gt; print(arr)</span>
<span class="sd">    array([</span>
<span class="sd">        [0, 0, 0],</span>
<span class="sd">        [0, 0, 1],</span>
<span class="sd">        [0, 0, 2],</span>
<span class="sd">        [0, 1, 0],</span>
<span class="sd">        [0, 1, 1],</span>
<span class="sd">        [0, 1, 2]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">idxs</span> <span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">])))</span></div>



<span class="c1">###########</span>
<span class="c1"># Spinors #</span>
<span class="c1">###########</span>

<div class="viewcode-block" id="DiracPauli">
<a class="viewcode-back" href="../../code.html#mhi.mhi.DiracPauli">[docs]</a>
<span class="k">class</span> <span class="nc">DiracPauli</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for Dirac matrices in the Dirac-Pauli basis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">g2</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">g4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps3</span> <span class="o">=</span> <span class="n">levi_civita</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Minkowski metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
            <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))],</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">1</span><span class="p">)]])</span>
        <span class="n">test_clifford</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">g1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g4</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="n">test_gamma5</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">g1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g4</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">g5</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="DiracPauli.rotation_vec">
<a class="viewcode-back" href="../../code.html#mhi.mhi.DiracPauli.rotation_vec">[docs]</a>
    <span class="k">def</span> <span class="nf">rotation_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the spinor rotation matrix associated with the 3-vector omega.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        omega: ``(3,)`` ndarray or list</span>
<span class="sd">            The vector specifying the rotation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arr : ``(4, 4)`` ndarray</span>
<span class="sd">            The complex roation matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;omega must be a 3-vector&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">g1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3</span><span class="p">]</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps3</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">+=</span> <span class="n">eps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">omega</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">arg</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">0.25</span>
        <span class="k">return</span> <span class="n">expm</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span></div>


<div class="viewcode-block" id="DiracPauli.rotation">
<a class="viewcode-back" href="../../code.html#mhi.mhi.DiracPauli.rotation">[docs]</a>
    <span class="k">def</span> <span class="nf">rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the spinor rotation matrix associated with an rotation</span>
<span class="sd">        of angle &quot;theta&quot; around the kth axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta: float</span>
<span class="sd">            The rotation angle</span>
<span class="sd">        direction: int</span>
<span class="sd">            The axis number, with {1,2,3} &lt;--&gt; {x,y,z}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arr : ``(4, 4)`` ndarray</span>
<span class="sd">            The complex rotation matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;Please specify direction in (1,2,3).&quot;</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">omega</span><span class="p">[</span><span class="n">direction</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_vec</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="get_nprod">
<a class="viewcode-back" href="../../code.html#mhi.mhi.get_nprod">[docs]</a>
<span class="k">def</span> <span class="nf">get_nprod</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the number of spin-1/2 copies present for a given half-integer j.</span>

<span class="sd">    For example, 3/2 = 1/2 \otimes 1/2 \otimes 1/2 --&gt; 3 copies</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : int or float</span>
<span class="sd">        The total spin.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of spin-1/2 copies present.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nprod</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nprod</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">nprod</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(),</span>\
        <span class="s2">&quot;Error: total j should be half-integer.&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">nprod</span><span class="p">)</span></div>



<div class="viewcode-block" id="make_spinor_array">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_spinor_array">[docs]</a>
<span class="k">def</span> <span class="nf">make_spinor_array</span><span class="p">(</span><span class="n">spinor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a normalized &quot;state&quot; with total (j, jz, parity) inside a suitable</span>
<span class="sd">    tensor product space of spin-1/2 states.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spinor : SpinorTuple</span>
<span class="sd">        The namedtuple specifying (j, jz, parity)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vec : ndarray</span>
<span class="sd">        The normalized vector of length 4**(2*j)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nprod</span> <span class="o">=</span> <span class="n">get_nprod</span><span class="p">(</span><span class="n">spinor</span><span class="o">.</span><span class="n">j</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">spinor</span><span class="o">.</span><span class="n">parity</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;Error: parity must be +/- 1&quot;</span>

    <span class="c1"># The basic spin-1/2 space is four dimensional, depending on the choice of</span>
    <span class="c1"># jz and parity. Represent the full space as a flattened tensor product of</span>
    <span class="c1"># (jz, parity) states</span>
    <span class="n">spin_half_basis</span> <span class="o">=</span> <span class="p">[(</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">idxs</span> <span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">spin_half_basis</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">nprod</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="c1"># Find desired total jz: sum the constituent jz values for each state</span>
    <span class="n">jz_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">basis</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">spinor</span><span class="o">.</span><span class="n">jz</span><span class="p">)</span>  <span class="c1"># (jz, parity) -&gt; jz</span>

    <span class="c1"># Find desired total parity. Note that:</span>
    <span class="c1"># all +1 --&gt; positive</span>
    <span class="c1"># all -1 --&gt; negative</span>
    <span class="c1"># else   --&gt; mixed parity</span>
    <span class="n">parity_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">basis</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (jz, parity) -&gt; parity</span>
    <span class="n">parity_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">parity_sum</span> <span class="o">==</span> <span class="n">spinor</span><span class="o">.</span><span class="n">parity</span><span class="o">*</span><span class="n">nprod</span><span class="p">)</span>

    <span class="c1"># Build normalized state with (j, jz, parity) in the tensor product space</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">))</span>
    <span class="n">vec</span><span class="p">[</span><span class="n">jz_mask</span> <span class="o">&amp;</span> <span class="n">parity_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">vec</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vec</span></div>



<span class="c1">########################</span>
<span class="c1"># General group theory #</span>
<span class="c1">########################</span>

<div class="viewcode-block" id="make_oh">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_oh">[docs]</a>
<span class="k">def</span> <span class="nf">make_oh</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a presentation of the cubic group Oh with a standardized</span>
<span class="sd">    ordering of group elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    group : ``(48, 3, 3)`` ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Reflections</span>
    <span class="n">rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">rz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">id3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">refls</span> <span class="o">=</span> <span class="p">[</span><span class="n">id3</span><span class="p">,</span> <span class="n">rz</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">ry</span><span class="nd">@rz</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">rx</span><span class="nd">@rz</span><span class="p">,</span> <span class="n">rx</span><span class="nd">@ry</span><span class="p">,</span> <span class="n">rx</span><span class="nd">@ry@rz</span><span class="p">]</span>

    <span class="c1"># Permutations</span>
    <span class="n">pxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">pyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="n">pzy</span> <span class="o">=</span> <span class="n">pyz</span>
    <span class="n">pzx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="n">pxz</span> <span class="o">=</span> <span class="n">pzx</span>
    <span class="n">perms</span> <span class="o">=</span> <span class="p">[</span><span class="n">id3</span><span class="p">,</span> <span class="n">pxy</span><span class="p">,</span> <span class="n">pyz</span><span class="p">,</span> <span class="n">pxz</span><span class="p">,</span> <span class="n">pxy</span><span class="nd">@pyz</span><span class="p">,</span> <span class="n">pxz</span><span class="nd">@pzy</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="nd">@p</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">refls</span><span class="p">,</span> <span class="n">perms</span><span class="p">)])</span></div>



<div class="viewcode-block" id="rotation">
<a class="viewcode-back" href="../../code.html#mhi.mhi.rotation">[docs]</a>
<span class="k">def</span> <span class="nf">rotation</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the rotation matrix by the angle theta around a particular axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : float</span>
<span class="sd">        The angle</span>
<span class="sd">    direction: int</span>
<span class="sd">        The axis number, with {1,2,3} &lt;--&gt; {x,y,z}.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ``(3, 3)`` ndarray</span>
<span class="sd">        The rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;Please specify direction in (1,2,3).&quot;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">omega</span><span class="p">[</span><span class="n">direction</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span>
    <span class="k">return</span> <span class="n">rotation_vec</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span></div>



<div class="viewcode-block" id="rotation_vec">
<a class="viewcode-back" href="../../code.html#mhi.mhi.rotation_vec">[docs]</a>
<span class="k">def</span> <span class="nf">rotation_vec</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the rotation matrix associated with the three-vector omega.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    omega : ``(3, )`` ndarray or list</span>
<span class="sd">        The vector defining the rotation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ``(3, 3)`` ndarray</span>
<span class="sd">        The rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;omega must be a 3-vector&quot;</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">levi_civita</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expm</span><span class="p">(</span><span class="o">-</span><span class="n">eps</span> <span class="o">@</span> <span class="n">omega</span><span class="p">)</span></div>



<div class="viewcode-block" id="make_ohd">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_ohd">[docs]</a>
<span class="k">def</span> <span class="nf">make_ohd</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a presentation of the &quot;spinorial&quot; double cover OhD of</span>
<span class="sd">    the cubic group ordering of group elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    group : ``(96, 4, 4)`` ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dirac</span> <span class="o">=</span> <span class="n">DiracPauli</span><span class="p">()</span>

    <span class="n">id4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">invs</span> <span class="o">=</span> <span class="p">[</span><span class="n">id4</span><span class="p">,</span> <span class="o">-</span><span class="n">id4</span><span class="p">]</span>  <span class="c1"># Note: 2*pi rotation != id in OhD</span>

    <span class="c1"># Reflections</span>
    <span class="n">Rx</span> <span class="o">=</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g5</span> <span class="o">@</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g1</span>
    <span class="n">Ry</span> <span class="o">=</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g5</span> <span class="o">@</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g2</span>
    <span class="n">Rz</span> <span class="o">=</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g5</span> <span class="o">@</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g3</span>
    <span class="n">refls</span> <span class="o">=</span> <span class="p">[</span><span class="n">id4</span><span class="p">,</span> <span class="n">Rz</span><span class="p">,</span> <span class="n">Ry</span><span class="p">,</span> <span class="n">Ry</span><span class="nd">@Rz</span><span class="p">,</span> <span class="n">Rx</span><span class="p">,</span> <span class="n">Rx</span><span class="nd">@Rz</span><span class="p">,</span> <span class="n">Rx</span><span class="nd">@Ry</span><span class="p">,</span> <span class="n">Rx</span><span class="nd">@Ry@Rz</span><span class="p">]</span>

    <span class="c1"># Permutations</span>
    <span class="n">Pxy</span> <span class="o">=</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g5</span> <span class="o">@</span> <span class="p">(</span><span class="n">dirac</span><span class="o">.</span><span class="n">g1</span> <span class="o">-</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Pyz</span> <span class="o">=</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g5</span> <span class="o">@</span> <span class="p">(</span><span class="n">dirac</span><span class="o">.</span><span class="n">g2</span> <span class="o">-</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g3</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Pzx</span> <span class="o">=</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g5</span> <span class="o">@</span> <span class="p">(</span><span class="n">dirac</span><span class="o">.</span><span class="n">g3</span> <span class="o">-</span> <span class="n">dirac</span><span class="o">.</span><span class="n">g1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">perms</span> <span class="o">=</span> <span class="p">[</span><span class="n">id4</span><span class="p">,</span> <span class="n">Pxy</span><span class="p">,</span> <span class="n">Pyz</span><span class="p">,</span> <span class="n">Pzx</span><span class="p">,</span> <span class="n">Pxy</span> <span class="o">@</span> <span class="n">Pyz</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Pxy</span> <span class="o">@</span> <span class="n">Pyz</span><span class="p">)]</span>

    <span class="c1"># Present group as a flattened tensor product elements</span>
    <span class="n">ohd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">i</span><span class="nd">@r@p</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">invs</span><span class="p">,</span> <span class="n">refls</span><span class="p">,</span> <span class="n">perms</span><span class="p">)])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ohd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">96</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unexpected group size </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ohd</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">ohd</span></div>



<div class="viewcode-block" id="make_spinorial_little_group">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_spinorial_little_group">[docs]</a>
<span class="k">def</span> <span class="nf">make_spinorial_little_group</span><span class="p">(</span><span class="n">little</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes the &quot;spinorial&quot; little group associated with the double cover OhD,</span>
<span class="sd">    given a little group G in Oh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    little : ``(|G|, 3, 3)`` array_like</span>
<span class="sd">        The little group G.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    group : ``(2*|G|, 4, 4)`` ndarray</span>
<span class="sd">        The double-cover little group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">oh_group</span> <span class="o">=</span> <span class="n">make_oh</span><span class="p">()</span>
    <span class="n">ohd_group</span> <span class="o">=</span> <span class="n">make_ohd</span><span class="p">()</span>
    <span class="c1"># Compute locations of little-group elements within Oh</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">gg</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">gg</span> <span class="ow">in</span> <span class="n">oh_group</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">little</span><span class="p">])</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">idxs</span><span class="p">,</span> <span class="n">idxs</span><span class="o">+</span><span class="mi">48</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ohd_group</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>



<div class="viewcode-block" id="make_stabilizer">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_stabilizer">[docs]</a>
<span class="k">def</span> <span class="nf">make_stabilizer</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs the stabilizer subgroup of an ordered set of momenta.</span>
<span class="sd">    The stabilizer group is the subgroup that leaves the ordered set invariant.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    momenta : ``(nmomenta, 3)`` or ``(3, )`` array_like</span>
<span class="sd">        The ordered set of momenta that must be left invariant.</span>
<span class="sd">    group : ``(|G|, 3, 3)`` array_like</span>
<span class="sd">        The total group.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stabilizer : ``(|H|, 3, 3)`` ndarray</span>
<span class="sd">        The stabilizer group H.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">momenta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">momenta</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">momenta</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">stab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">g</span><span class="nd">@momenta</span><span class="p">,</span> <span class="n">momenta</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">stab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group</span> <span class="k">if</span>
                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ab,ib-&gt;ia&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">momenta</span><span class="p">),</span>
                            <span class="n">momenta</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">stab</span></div>



<div class="viewcode-block" id="make_canonical_stabilizer">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_canonical_stabilizer">[docs]</a>
<span class="k">def</span> <span class="nf">make_canonical_stabilizer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the stabilizer subgroup with a canonical orientation inside the</span>
<span class="sd">    larger group Oh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the desired stabilizer subgroup</span>
<span class="sd">    group : ``(|G|, 3, 3)`` array_like</span>
<span class="sd">        The group</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stabilizer : ``(|H|, 3, 3)`` array_like</span>
<span class="sd">        The stabilizer subgroup</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">canonical_momenta</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Oh&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
        <span class="s2">&quot;C4v&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span>
        <span class="s2">&quot;C3v&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span>
        <span class="s2">&quot;C2v&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span>
        <span class="s2">&quot;C2R&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
        <span class="s2">&quot;C2P&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span>
        <span class="s2">&quot;C1&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span>
    <span class="p">}</span>
    <span class="n">ktot</span> <span class="o">=</span> <span class="n">canonical_momenta</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">make_stabilizer</span><span class="p">(</span><span class="n">ktot</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span></div>



<div class="viewcode-block" id="identify_stabilizer">
<a class="viewcode-back" href="../../code.html#mhi.mhi.identify_stabilizer">[docs]</a>
<span class="k">def</span> <span class="nf">identify_stabilizer</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies the name of the stabilizer group &quot;H&quot; by checking its order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stabilizer : ``(|H|, 3, 3)`` array_like</span>
<span class="sd">        The stabilizer group.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the stabilizer group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">stabilizer</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]):</span>
            <span class="k">return</span> <span class="s1">&#39;C2R&#39;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]):</span>
            <span class="k">return</span> <span class="s1">&#39;C2P&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to identify stabilizer group.&quot;</span><span class="p">)</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">48</span><span class="p">:</span> <span class="s2">&quot;Oh&quot;</span><span class="p">,</span>
        <span class="mi">8</span><span class="p">:</span> <span class="s2">&quot;C4v&quot;</span><span class="p">,</span>
        <span class="mi">6</span><span class="p">:</span> <span class="s2">&quot;C3v&quot;</span><span class="p">,</span>
        <span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;C2v&quot;</span><span class="p">,</span>
        <span class="c1"># 2: handled separately above for C2P and C2R</span>
        <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;C1&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dims</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span></div>



<div class="viewcode-block" id="make_little_and_stabilizer">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_little_and_stabilizer">[docs]</a>
<span class="k">def</span> <span class="nf">make_little_and_stabilizer</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the little group and stabilizer group of the ordered set of momenta.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    momenta : ``(nmomenta, 3)`` array_like</span>
<span class="sd">        The momenta</span>
<span class="sd">    group : ``(|G|, 3, 3)`` array_like</span>
<span class="sd">        The group</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    groups : tuple = (ndarray, ndarray)</span>
<span class="sd">        A pair of groups arranged as (&quot;little group&quot;, &quot;stabilizer group&quot;)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A word on physics naming conventions.</span>
<span class="sd">    Let G be a group, let momenta be a set of ordered momenta, and let</span>
<span class="sd">    ktot be the total momentum (i.e., the sum of the momenta).</span>
<span class="sd">    The &quot;little group&quot; is the subgroup of G that leaves ktot invariant.</span>
<span class="sd">    The &quot;stabilizer group&quot; is the subgroup of G that leaves momenta invariant.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ktot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ktot</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Error: expected 3-vector for total momentum.&quot;</span>
    <span class="n">little</span> <span class="o">=</span> <span class="n">make_stabilizer</span><span class="p">(</span><span class="n">ktot</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
    <span class="n">stab</span> <span class="o">=</span> <span class="n">make_stabilizer</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">little</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">little</span><span class="p">,</span> <span class="n">stab</span><span class="p">)</span></div>



<div class="viewcode-block" id="conjugate">
<a class="viewcode-back" href="../../code.html#mhi.mhi.conjugate">[docs]</a>
<span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the conjugate of group element h by group element g:</span>
<span class="sd">    :math:`g.h.g^{-1}`.  Assumes that g is an orthogonal matrix so that</span>
<span class="sd">    :math:`g^{-1} = g^T`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : ``(n, n)`` ndarray</span>
<span class="sd">    h : ``(n, n)`` ndarray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    h_conj : ``(n, n)`` ndarray</span>
<span class="sd">        The conjugated element, :math:`g.h.g^{-1}`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">g</span> <span class="o">@</span> <span class="n">h</span> <span class="o">@</span> <span class="n">g</span><span class="o">.</span><span class="n">T</span></div>



<div class="viewcode-block" id="conjugate_group">
<a class="viewcode-back" href="../../code.html#mhi.mhi.conjugate_group">[docs]</a>
<span class="k">def</span> <span class="nf">conjugate_group</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the conjugate of the group G by the group element g: :math:`g.G.g^{-1}`.</span>
<span class="sd">    Assumes that g is an orthogonal matrix so that :math:`g^{-1} = g^T`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group : ``(|G|, n, n)`` ndarray</span>
<span class="sd">        The group G.</span>
<span class="sd">    h : ``(n, n)`` ndarray</span>
<span class="sd">        The conjugating element.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    group_conj : ``(|G|, n, n)`` ndarray</span>
<span class="sd">        The conjugated group :math:`g.G.g^{-1}`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">conjugate</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">elt</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">group</span><span class="p">])</span></div>



<div class="viewcode-block" id="find_subgroup_isomorphism">
<a class="viewcode-back" href="../../code.html#mhi.mhi.find_subgroup_isomorphism">[docs]</a>
<span class="k">def</span> <span class="nf">find_subgroup_isomorphism</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">subgroup_h1</span> <span class="p">,</span> <span class="n">subgroup_h2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the isomorphism between conjugate subgroups H1 and H2.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group : ``(|G|, n, n)`` ndarray</span>
<span class="sd">        The group G.</span>
<span class="sd">    subgroup_h1 : ``(|H|, n, n)`` ndarray</span>
<span class="sd">        The subgroup H1.</span>
<span class="sd">    subgroup_h2 : ``(|H|, n, n)`` ndarray</span>
<span class="sd">        The subgroup H2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (g, perm) : :class:`Isomorphism`</span>
<span class="sd">        The group element and permutation specifying the isomorphism.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">subgroup_h1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">subgroup_h2</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>\
        <span class="sa">f</span><span class="s2">&quot;Incomensurate shapes for subgroups H1 and H2: </span><span class="si">{</span><span class="n">subgroup_h1</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">subgroup_h2</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">assert</span> <span class="n">group</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">subgroup_h1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>\
        <span class="sa">f</span><span class="s2">&quot;Incomensurate shapes for group G and the subgroup H1: </span><span class="si">{</span><span class="n">group</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">subgroup_h1</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the indices that would sort the group, using a hash</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="n">force_hash</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group</span><span class="p">])</span>

    <span class="n">ridx2</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">subgroup_h2</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
        <span class="n">h1_conj</span> <span class="o">=</span> <span class="n">conjugate_group</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">subgroup_h1</span><span class="p">)</span>
        <span class="n">idx1</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">h1_conj</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">idx1</span><span class="p">[</span><span class="n">ridx2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">h1_conj</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">subgroup_h2</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Failed to locate an isomorphism.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Isomorphism</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span></div>



<div class="viewcode-block" id="apply_isomorphism">
<a class="viewcode-back" href="../../code.html#mhi.mhi.apply_isomorphism">[docs]</a>
<span class="k">def</span> <span class="nf">apply_isomorphism</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">isomorphism</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies the isomorphism (g, perm) to the group G via :math:`(g.G.g^{-1})[perm]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group : ``(|G|, n, n)`` ndarray</span>
<span class="sd">    isomorphism : :class:`Isomorphism`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    group_iso : ``(|G|, n, n)`` ndarray</span>
<span class="sd">        The group after applying the isomorphism, :math:`(g.G.g^{-1})[perm]`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">conjugate_group</span><span class="p">(</span><span class="n">isomorphism</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">group</span><span class="p">)[</span><span class="n">isomorphism</span><span class="o">.</span><span class="n">perm</span><span class="p">]</span></div>



<span class="c1">######################</span>
<span class="c1"># Orbit construction #</span>
<span class="c1">######################</span>

<div class="viewcode-block" id="force_hash">
<a class="viewcode-back" href="../../code.html#mhi.mhi.force_hash">[docs]</a>
<span class="k">def</span> <span class="nf">force_hash</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a hash for an array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">sha256</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span></div>



<div class="viewcode-block" id="HashableArray">
<a class="viewcode-back" href="../../code.html#mhi.mhi.HashableArray">[docs]</a>
<span class="k">class</span> <span class="nc">HashableArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Minimal wrapper to make arrays hashable based on their value at</span>
<span class="sd">    initialization. Basically copied from the docs:</span>
<span class="sd">    https://docs.scipy.org/doc/numpy/user/basics.subclassing.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dset</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arr</span> <span class="o">=</span> <span class="n">arr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="n">force_hash</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;attrs&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arr</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span></div>



<div class="viewcode-block" id="MomentumSpinOrbitElement">
<a class="viewcode-back" href="../../code.html#mhi.mhi.MomentumSpinOrbitElement">[docs]</a>
<span class="k">class</span> <span class="nc">MomentumSpinOrbitElement</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for easy manipulations involving elements of momentum-spin orbits.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">momenta</span><span class="p">,</span> <span class="n">spins</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">momenta</span> <span class="o">=</span> <span class="n">momenta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="o">=</span> <span class="n">spins</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">momenta</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">momenta</span><span class="p">)</span> <span class="ow">and</span>\
            <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spins</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">spins</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MomentumSpinOrbitElement</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">momenta</span><span class="p">[</span><span class="n">perm</span><span class="p">,:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span><span class="p">[</span><span class="n">perm</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;MomentumSpinOrbitElement(momenta=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">momenta</span><span class="si">}</span><span class="s2">, spins=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spins</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>



<div class="viewcode-block" id="make_momentum_orbit">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_momentum_orbit">[docs]</a>
<span class="k">def</span> <span class="nf">make_momentum_orbit</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">exchange_group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the orbit of an ordered set of vectors under a group action.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    momenta : ``(nmomenta, 3)`` array_like</span>
<span class="sd">        The ordered momenta.</span>
<span class="sd">    group : ``(|G|, 3, 3)`` array_like</span>
<span class="sd">        The group matrices.</span>
<span class="sd">    exchange_group : list of :class:`WeightedPermutation`</span>
<span class="sd">        The exchange group projector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    orbit : list</span>
<span class="sd">        The matrices corresponding to ordered momenta in the orbit.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In abstract algebra, an orbit is often considered as an unordered set.</span>
<span class="sd">    For numerical work, it is useful to work with orbits ordered in a standard</span>
<span class="sd">    way. The convention in the present work is that the orbit inherits its</span>
<span class="sd">    order from that of the group elements acting on the original starting</span>
<span class="sd">    vector (or ordered list of vectors.) When a given (set of) vector(s) arises</span>
<span class="sd">    more than once, the first instance defines the location of the vector(s)</span>
<span class="sd">    within the orbit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">momenta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span>
        <span class="s2">&quot;Incommensurate shape for product g@momenta.T, &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;g=</span><span class="si">{</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> momenta=</span><span class="si">{</span><span class="n">momenta</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exchange_group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">exchange_group</span> <span class="o">=</span> <span class="p">[</span><span class="n">WeightedPermutation</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">momenta</span><span class="p">)))]</span>

    <span class="c1"># Create the shell</span>
    <span class="n">shell</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">group_element</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
        <span class="c1"># Note: g acts on each momentum vector within &quot;momenta&quot;.</span>
        <span class="n">momenta_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ab,ib-&gt;ia&quot;</span><span class="p">,</span> <span class="n">group_element</span><span class="p">,</span> <span class="n">momenta</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">HashableArray</span><span class="p">(</span><span class="n">momenta_new</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shell</span><span class="p">:</span>
            <span class="n">shell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="c1"># Apply the exchange group</span>
    <span class="c1"># Note: These separate loops for creating the shell and apply the exchange</span>
    <span class="c1"># group could be combined at the price of changing the ordering of the shell.</span>
    <span class="k">for</span> <span class="n">exchange_element</span> <span class="ow">in</span> <span class="n">exchange_group</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">shell</span><span class="p">[:]:</span>
            <span class="n">arr_new</span> <span class="o">=</span> <span class="n">HashableArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">exchange_element</span><span class="o">.</span><span class="n">perm</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">arr_new</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shell</span><span class="p">:</span>
                <span class="n">shell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_new</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shell</span><span class="p">)</span></div>



<div class="viewcode-block" id="make_momentum_spin_orbit">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_momentum_spin_orbit">[docs]</a>
<span class="k">def</span> <span class="nf">make_momentum_spin_orbit</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">spin_dims</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">exchange_group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the momentum-spin orbit, i.e., the tensor product of the</span>
<span class="sd">    momentum orbit and the associated spinor orbit.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    momenta : ``(nmomenta, 3)`` array_like</span>
<span class="sd">        The ordered momenta</span>
<span class="sd">    spin_dims : list of ints</span>
<span class="sd">        The dimensions of the spinor spaces.</span>
<span class="sd">    group : ``(|G|, 3, 3)`` array_like</span>
<span class="sd">        The group matrices.</span>
<span class="sd">    exchange : array_like or None</span>
<span class="sd">        The exchange_group with namedtuple/WeightedPermutation elements</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spin_shell : ndarray</span>
<span class="sd">        The flattened tensor product.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Consider a spinor transforming in an N-dimensional irrep.</span>
<span class="sd">    By definition, the different basis vectors for the irrep transform</span>
<span class="sd">    into each other under the action of the group.</span>
<span class="sd">    Thus, the spinorial part of the shell is just the tensor product</span>
<span class="sd">    of all the individual spinor spaces.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">orbit</span> <span class="o">=</span> <span class="n">make_momentum_orbit</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">exchange_group</span><span class="p">)</span>
    <span class="n">spin_space</span> <span class="o">=</span> <span class="n">make_tensor_product_space</span><span class="p">(</span><span class="n">spin_dims</span><span class="p">)</span>
    <span class="c1"># Compute flattened tensor product</span>
    <span class="n">spin_shell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">spin_space</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">mom</span><span class="p">,</span> <span class="n">spins</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">spin_space</span><span class="p">)):</span>
        <span class="n">spin_shell</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpinShellTuple</span><span class="p">(</span><span class="n">mom</span><span class="p">,</span> <span class="n">spins</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spin_shell</span></div>



<div class="viewcode-block" id="parity">
<a class="viewcode-back" href="../../code.html#mhi.mhi.parity">[docs]</a>
<span class="k">def</span> <span class="nf">parity</span><span class="p">(</span><span class="n">permutation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the parity of permutation, assumed to be specified as a list of</span>
<span class="sd">    contiguous integers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    permutation: array_like</span>
<span class="sd">        The permutation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sign: +1 or -1</span>
<span class="sd">        The parity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; parity([2,3,4,5])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; parity([5,2,3,4])</span>
<span class="sd">    -1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">permutation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
    <span class="n">permutation</span> <span class="o">=</span> <span class="n">permutation</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>  <span class="c1"># Work with respect to zero</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">==</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">permutation</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non-contiguous integers: </span><span class="si">{</span><span class="n">permutation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">permutation</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="n">permutation</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span>
            <span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">permutation</span><span class="p">[</span><span class="n">mn</span><span class="p">]</span> <span class="o">=</span> <span class="n">permutation</span><span class="p">[</span><span class="n">mn</span><span class="p">],</span> <span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sign</span></div>



<div class="viewcode-block" id="partition">
<a class="viewcode-back" href="../../code.html#mhi.mhi.partition">[docs]</a>
<span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the partitions of the array according to the unique elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        The array to partition</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    partitions : dict</span>
<span class="sd">        The partitions, where the keys are the unique entries of the input array</span>
<span class="sd">        and the values are the associated indices in the input array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The keys are sorted according to the first appearance in arr</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; partition([&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39;]))</span>
<span class="sd">    {&#39;a&#39;: array([0]), &#39;b&#39;: array([1, 2]), &#39;c&#39;: array([3])}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">{</span><span class="n">elt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">arr</span> <span class="o">==</span> <span class="n">elt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arr</span><span class="p">)}</span>
    <span class="c1"># Sort keys according to their first appearance</span>
    <span class="n">keys</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">idxs</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">tmp</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">tmp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span></div>



<div class="viewcode-block" id="recombine">
<a class="viewcode-back" href="../../code.html#mhi.mhi.recombine">[docs]</a>
<span class="k">def</span> <span class="nf">recombine</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">partition_keys</span><span class="p">,</span> <span class="n">partition_idxs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recombines indices from partitioned sets.</span>
<span class="sd">    This function is equivalent to concatenating the indices for contiguous labels.</span>
<span class="sd">    For instance, [&#39;b1&#39;, &#39;b1&#39;, &#39;b2] are contiguous, but [&#39;b1&#39;, &#39;b2&#39;, &#39;b1&#39;] are not.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : ``(n, )`` array_like</span>
<span class="sd">        The labels, e.g., [&#39;b1&#39;, &#39;b2&#39;, &#39;b1&#39;]</span>
<span class="sd">    partition_keys : ``(m, )`` array_like</span>
<span class="sd">        The unique elements of the labels, ordered by first appearance.</span>
<span class="sd">    partition_idxs : ``(m, )`` tuple of array_like</span>
<span class="sd">        The indices to recombine, in the same order as the partition_keys</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idxs : ``(n, )`` ndarray</span>
<span class="sd">        The recombined indices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    This example builds the tensor product of permutations on the set of labels</span>
<span class="sd">    [&#39;b1&#39;,&#39;b2&#39;,&#39;b1&#39;]. Since the label &#39;b1&#39; is not contiguous, the permutations</span>
<span class="sd">    associated with this label should include the identity (0)(2) and the swap</span>
<span class="sd">    (0,2).</span>

<span class="sd">    &gt;&gt;&gt; labels = [&#39;b1&#39;,&#39;b2&#39;,&#39;b1&#39;]</span>
<span class="sd">    &gt;&gt;&gt; partitions = partition(labels)</span>
<span class="sd">    &gt;&gt;&gt; perms = {key: list(itertools.permutations(idxs)) for key, idxs in partitions.items()}</span>
<span class="sd">    &gt;&gt;&gt; keys = np.array(list(partitions.keys()))</span>
<span class="sd">    &gt;&gt;&gt; for idxs in itertools.product(*perms.values()):</span>
<span class="sd">    &gt;&gt;&gt;     print(mhi.recombine(labels, keys, idxs), &quot;(correct)&quot;)</span>
<span class="sd">    &gt;&gt;&gt;     print(np.concatenate(idxs), &quot;(wrong)&quot;)</span>
<span class="sd">    [0 1 2] (correct)</span>
<span class="sd">    [0 2 1] (wrong)</span>
<span class="sd">    [2 1 0] (correct)</span>
<span class="sd">    [2 0 1] (wrong)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">partition_keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">partition_idxs</span><span class="p">),</span>\
        <span class="s2">&quot;Incommensurate partition_keys and indices&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">partition_idxs</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span>\
        <span class="s2">&quot;Incommensurate labels and indices.&quot;</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">iterators_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">partition_idxs</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">partition_keys</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iterators_idxs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">idxs</span></div>



<div class="viewcode-block" id="make_exchange_projector">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_exchange_projector">[docs]</a>
<span class="k">def</span> <span class="nf">make_exchange_projector</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">tableau_map</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a projector in the group algebra of the particle-exchange group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : list</span>
<span class="sd">        Particle labels, e.g., [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;b&#39;,&#39;c&#39;,&#39;b&#39;]</span>
<span class="sd">    tableau_map : dict</span>
<span class="sd">        Young tableaux associated with each label, e.g.,</span>
<span class="sd">        {&#39;a&#39;: [[1]], &#39;b&#39;: [[1,2],[3]], &#39;c&#39;: [[1],[2]],}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    projector : list of WeightedPermutation objects</span>
<span class="sd">        The projection operator in the group algebra of the exchange group</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">partitions</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tableau_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; missing from tableau_map.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid_tableau</span><span class="p">(</span><span class="n">tableau_map</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid Young tableau for key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">partitions</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tableau_map</span><span class="p">[</span><span class="n">key</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect tableau size for key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remap_indices</span><span class="p">(</span><span class="n">idxs</span><span class="p">,</span> <span class="n">wp</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">WeightedPermutation</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">idxs</span><span class="p">[</span><span class="n">wp</span><span class="o">.</span><span class="n">perm</span><span class="p">])</span>

    <span class="c1"># Compute individual projectors associated with each label</span>
    <span class="n">projectors</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">:</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># Compute Young projector on contiguous indices 1,2,...,len(idxs)</span>
        <span class="n">proj_tmp</span> <span class="o">=</span>  <span class="n">make_young_projector</span><span class="p">(</span><span class="n">tableau_map</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">))</span>
        <span class="c1"># Remap contiguous indices to the indices of the label</span>
        <span class="n">projectors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">remap_indices</span><span class="p">(</span><span class="n">idxs</span><span class="p">,</span> <span class="n">wp</span><span class="p">)</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">proj_tmp</span><span class="p">]</span>

    <span class="c1"># Compute tensor product of the projectors from each label</span>
    <span class="n">projector</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">partitions</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">for</span> <span class="n">wps</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">projectors</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">wp</span><span class="o">.</span><span class="n">perm</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">wps</span><span class="p">]</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="n">wp</span><span class="o">.</span><span class="n">weight</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">wps</span><span class="p">])</span>
        <span class="n">projector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">WeightedPermutation</span><span class="p">(</span>
                <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                <span class="n">perm</span><span class="o">=</span><span class="n">recombine</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">idxs</span><span class="p">)))</span>

    <span class="k">assert</span> <span class="n">algebra_elements_are_close</span><span class="p">(</span>
        <span class="n">projector</span><span class="p">,</span>
        <span class="n">compose_permutation_algebra_elements</span><span class="p">(</span><span class="n">projector</span><span class="p">,</span> <span class="n">projector</span><span class="p">)),</span>\
        <span class="s2">&quot;Error: Projector not idempotent!&quot;</span>
    <span class="k">return</span> <span class="n">projector</span></div>



<div class="viewcode-block" id="make_exchange_projector_identical">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_exchange_projector_identical">[docs]</a>
<span class="k">def</span> <span class="nf">make_exchange_projector_identical</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the exchange group associated with exchange of identical particles.</span>
<span class="sd">    The elements of this group are signed permuations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : array_like or None</span>
<span class="sd">        The labels associated with the particles.</span>
<span class="sd">    fermions : dict</span>
<span class="sd">        Whether a given key (label) corresponds to a fermion.</span>
<span class="sd">        Values must be booleans: True for fermions and False for bosons.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    exchange_group : list or None</span>
<span class="sd">        The exchange group, with namedtuple/WeightedPermutation elements.</span>
<span class="sd">        The result is None when no labels are specified.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Generic fermions are labeled &#39;f{n}&#39; for integers n, e.g., &#39;f1&#39;, &#39;f2, ...</span>
<span class="sd">    Generic bosons are labeld &#39;b{n}&#39; for integers n, e.g., &#39;b1&#39;, &#39;b2&#39;, ...</span>
<span class="sd">    Support also exists for certain named particles like &#39;pi&#39;, &#39;K&#39;, &#39;neutron&#39;,</span>
<span class="sd">    &#39;proton&#39;, &#39;nucleon&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># No labels specified</span>

    <span class="n">table</span> <span class="o">=</span> <span class="n">load_particle_info</span><span class="p">()</span>
    <span class="n">fermions</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span> <span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">is_fermion</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">fermion_template</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(f|F)(|-?|\d+)&#39;</span><span class="p">)</span>  <span class="c1"># generic fermion, e.g., f1</span>
    <span class="n">boson_template</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">((</span><span class="sa">r</span><span class="s1">&#39;(b|B)(|-?|\d+)&#39;</span><span class="p">))</span>  <span class="c1"># generic boson, e.g., b1</span>

    <span class="c1"># Verify inputs</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fermion_template</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="n">fermions</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">boson_template</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="n">fermions</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">assert</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">fermions</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Missing fermion/boson specification for </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fermions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Bad specification for </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">. Expected a bool.&quot;</span>

    <span class="c1"># Decide which particles have the same labels</span>
    <span class="n">partitions</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">partitions</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="c1"># Permutations associated with individual labels, ignoring signs</span>
    <span class="n">perms</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">idxs</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">partitions</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="c1"># parity**0 = 1 for bosons</span>
    <span class="c1"># parity**1 = parity for fermions</span>
    <span class="n">powers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">fermions</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">perms</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>

    <span class="c1"># The full list of permutations is the tensor product of the individual permutations</span>
    <span class="n">exchange_group</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">perms</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="c1"># Overall sign = product of the parities of the individual permuations</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span>
            <span class="n">parity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">))</span><span class="o">**</span><span class="n">power</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span> <span class="n">power</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idxs</span><span class="p">,</span> <span class="n">powers</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">recombine</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">idxs</span><span class="p">)</span>
        <span class="n">exchange_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">WeightedPermutation</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="n">sign</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="n">perm</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">exchange_group</span></div>



<div class="viewcode-block" id="make_internal_symmetry_projector">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_internal_symmetry_projector">[docs]</a>
<span class="k">def</span> <span class="nf">make_internal_symmetry_projector</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">internal_symmetry</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the projection matrix associated with an internal symmetry group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    momentum_spin_orbit : ``(n, )`` list of :class:`SpinShellTuple`</span>
<span class="sd">        Each element in the list defines the (momenta, spin) configuration for a</span>
<span class="sd">        given element of the orbit.</span>
<span class="sd">    internal_group : list of :class:`WeightedPermutation`</span>
<span class="sd">         The exchange group projector in the group algebra.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    proj : ``(n, n)`` ndarray</span>
<span class="sd">        projection matrix P, intended to be contracted against the extended</span>
<span class="sd">        momentum-spin representation matrices, giving projected matrices</span>
<span class="sd">        :math:`\hat{D}_{mm&#39;}(R) = P_{mn} D_{nn&#39;}(R) P_{nm&#39;}`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As a projection matrix, &quot;proj&quot; is idempotent: ``proj @ proj == proj``.</span>

<span class="sd">    The full internal symmetry operator can be thought of as a linear</span>
<span class="sd">    combination of permutations. The representation matrices can be computed</span>
<span class="sd">    either before or after taking the linear combination. This implementation</span>
<span class="sd">    takes the latter route, computing a representation matrix for each and</span>
<span class="sd">    taking a suitable linear combination.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">has_spins</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">orbit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;spins&#39;</span><span class="p">):</span>
        <span class="n">has_spins</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">internal_symmetry</span><span class="p">:</span>
        <span class="c1"># Permute the orbit</span>
        <span class="k">if</span> <span class="n">has_spins</span><span class="p">:</span>
            <span class="n">orbit_permuted</span> <span class="o">=</span> <span class="p">[</span><span class="n">SpinShellTuple</span><span class="p">(</span><span class="n">momenta</span><span class="p">[</span><span class="n">perm</span><span class="p">],</span> <span class="n">spins</span><span class="p">[</span><span class="n">perm</span><span class="p">])</span> <span class="k">for</span> <span class="n">momenta</span><span class="p">,</span> <span class="n">spins</span> <span class="ow">in</span> <span class="n">orbit</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orbit_permuted</span> <span class="o">=</span> <span class="p">[</span><span class="n">momenta</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span> <span class="k">for</span> <span class="n">momenta</span> <span class="ow">in</span> <span class="n">orbit</span><span class="p">]</span>
        <span class="c1"># Compute the matrix elements of the operator acting on the shell representation</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orbit_permuted</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">old</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orbit</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">has_spins</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">momenta</span><span class="p">,</span> <span class="n">old</span><span class="o">.</span><span class="n">momenta</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">spins</span><span class="p">,</span> <span class="n">old</span><span class="o">.</span><span class="n">spins</span><span class="p">):</span>
                        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">):</span>
                        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">proj</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">*</span> <span class="n">tmp</span>

    <span class="c1"># Projection matrices have eigenvalues [0, 1].</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evals</span><span class="p">))]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># Orbit is removed by the projector</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="n">proj</span> <span class="o">/</span> <span class="n">norm</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">proj</span> <span class="o">@</span> <span class="n">proj</span><span class="p">,</span> <span class="n">proj</span><span class="p">),</span> <span class="s2">&quot;Error: projector not idempotent&quot;</span>
    <span class="k">return</span> <span class="n">proj</span></div>



<div class="viewcode-block" id="multiply_perms">
<a class="viewcode-back" href="../../code.html#mhi.mhi.multiply_perms">[docs]</a>
<span class="k">def</span> <span class="nf">multiply_perms</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiply the permutations a and b.</span>

<span class="sd">    Group multiplication acts as composition when considering group elements as</span>
<span class="sd">    left-acting operators, i.e.,</span>
<span class="sd">    :math:`(a \cdot b)(v) = (a \circ b)(v) = a(b(v))`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : ``(n,)`` ndarray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        The product of permutations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">a</span><span class="p">]</span></div>



<div class="viewcode-block" id="invert_perm">
<a class="viewcode-back" href="../../code.html#mhi.mhi.invert_perm">[docs]</a>
<span class="k">def</span> <span class="nf">invert_perm</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the inverse permutation such that</span>
<span class="sd">    :math:`a \circ a^{-1} = a^{-1} \circ a = (1)`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ``(n,)`` array_like</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ainv : ``(n,)`` ndarray</span>
<span class="sd">        The inverse permutation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>



<div class="viewcode-block" id="compose_permutation_algebra_elements">
<a class="viewcode-back" href="../../code.html#mhi.mhi.compose_permutation_algebra_elements">[docs]</a>
<span class="k">def</span> <span class="nf">compose_permutation_algebra_elements</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the product of two elements in the algebra of the permutation group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : list of :class:`WeightedPermutation`</span>
<span class="sd">        The algebra elements to be multiplied.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        The product, as a list of :class:`WeightedPermutation` objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">w_perm1</span><span class="p">,</span> <span class="n">w_perm2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w_perm1</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">w_perm2</span><span class="o">.</span><span class="n">weight</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">multiply_perms</span><span class="p">(</span><span class="n">w_perm1</span><span class="o">.</span><span class="n">perm</span><span class="p">,</span> <span class="n">w_perm2</span><span class="o">.</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightedPermutation</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightedPermutation</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="o">+</span><span class="n">w</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">perm</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>



<div class="viewcode-block" id="algebra_elements_are_close">
<a class="viewcode-back" href="../../code.html#mhi.mhi.algebra_elements_are_close">[docs]</a>
<span class="k">def</span> <span class="nf">algebra_elements_are_close</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether elements of the group algebra of Sn are numerically close.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : list of :class:`WeightedPermutation` objects</span>
<span class="sd">        The group algebra elements.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    are_close : bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span><span class="k">return</span> <span class="kc">False</span>
    <span class="n">inds1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">wp</span><span class="o">.</span><span class="n">perm</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">x1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">inds2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">wp</span><span class="o">.</span><span class="n">perm</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">x2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)):</span>
        <span class="n">wp1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">inds1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">wp2</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="n">inds2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">wp1</span><span class="o">.</span><span class="n">perm</span> <span class="o">==</span> <span class="n">wp2</span><span class="o">.</span><span class="n">perm</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">wp1</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">wp2</span><span class="o">.</span><span class="n">weight</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="is_valid_tableau">
<a class="viewcode-back" href="../../code.html#mhi.mhi.is_valid_tableau">[docs]</a>
<span class="k">def</span> <span class="nf">is_valid_tableau</span><span class="p">(</span><span class="n">tableau</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether ragged list is a valid Young tableau.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tableau : list of lists</span>
<span class="sd">        The candidate Young tableau.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_valid : bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Row lengths never increase</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tableau</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># Values in rows strictly increasing</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tableau</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># Values in columns strictly increasing</span>
    <span class="n">tableau_t</span> <span class="o">=</span> <span class="n">transpose_tableau</span><span class="p">(</span><span class="n">tableau</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tableau_t</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="transpose_tableau">
<a class="viewcode-back" href="../../code.html#mhi.mhi.transpose_tableau">[docs]</a>
<span class="k">def</span> <span class="nf">transpose_tableau</span><span class="p">(</span><span class="n">tableau</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transposes a Young tableau.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tableau : list of lists</span>
<span class="sd">        The tableau, given as a ragged list of integers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tableau_t : list of lists</span>
<span class="sd">        The transposed tableau, as a ragged list of integers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tableau_t</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tableau</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">tableau_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tableau_t</span></div>



<div class="viewcode-block" id="symmetrizer">
<a class="viewcode-back" href="../../code.html#mhi.mhi.symmetrizer">[docs]</a>
<span class="k">def</span> <span class="nf">symmetrizer</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">signed</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes a symmetrizer over the specified indices.</span>

<span class="sd">    The symmetrizer is an element of the algebra of the group Sn that yields the</span>
<span class="sd">    symmetrized or anti-symmetrized (depending on `signed`) space over the</span>
<span class="sd">    indices in `row`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    row : array_like</span>
<span class="sd">        The (1-indexed) indices over which to symmetrize.</span>
<span class="sd">    signed : 0 or 1</span>
<span class="sd">        Whether to symmetrize (0) or antisymmetrize (1)</span>
<span class="sd">    n : The total number of indices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        The symmetrizer in the group algebra, represented as a list of</span>
<span class="sd">        WeightedPermutation objects.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Indices less than or equal to 1 are taken from the back of the list.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mhi.symmetrizer([1,2], signed=1, n=3)</span>
<span class="sd">    [WeightedPermutation(weight=1, perm=array([0, 1, 2])),</span>
<span class="sd">     WeightedPermutation(weight=-1, perm=array([1, 0, 2]))]</span>
<span class="sd">    &gt;&gt;&gt; mhi.symmetrizer([2,3], signed=0, n=3)</span>
<span class="sd">    [WeightedPermutation(weight=1, perm=array([0, 1, 2])),</span>
<span class="sd">     WeightedPermutation(weight=1, perm=array([1, 0, 2]))]</span>
<span class="sd">    &gt;&gt;&gt; mhi.symmetrizer([0,-1], signed=0, n=3)</span>
<span class="sd">    [WeightedPermutation(weight=1, perm=array([0, 1, 2])),</span>
<span class="sd">     WeightedPermutation(weight=1, perm=array([0, 2, 1]))]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">signed</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)))):</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="n">parity</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">sign</span><span class="o">**</span><span class="n">signed</span>
        <span class="n">tot_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">tot_perm</span><span class="p">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tot_perm</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">WeightedPermutation</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="n">tot_perm</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="make_young_projector">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_young_projector">[docs]</a>
<span class="k">def</span> <span class="nf">make_young_projector</span><span class="p">(</span><span class="n">tableau</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes the projection operator, acting on n indices, associated with the</span>
<span class="sd">    given Young tableau.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tableau : list of lists</span>
<span class="sd">        The Young tableau.</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of indices for which to construct the projector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    proj : list of WeightedPermutation objects</span>
<span class="sd">        The projection operator in the group algebra.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Young tableaux are specified by indices 1,2,3,.... starting with 1.</span>
<span class="sd">    Indices in python arrays are zero indexed.</span>
<span class="sd">    This implementation uses definition of the Hermitian projection operators</span>
<span class="sd">    given by Ref. [1]_. In particular, this function uses Eq (86) in Theorem 3</span>
<span class="sd">    (KS Hermitian Young projectors). For large tableaux, it would likely</span>
<span class="sd">    advantageous to switch to the Measure Of Lexical Disorder (MOLD) definition</span>
<span class="sd">    of the projection operators given in Theorem 5.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. Alcock-Zeilinger and H. Weigert</span>
<span class="sd">       &quot;Compact Hermitian Young Projection Operators&quot;</span>
<span class="sd">       J.Math.Phys. 58 (2017) 5, 051702</span>
<span class="sd">       [arXiv:1610.10088].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid_tableau</span><span class="p">(</span><span class="n">tableau</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid tableau&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tableau</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too few indices for specified tableau.&quot;</span><span class="p">)</span>

    <span class="c1"># Base case for the recursive definition</span>
    <span class="k">if</span> <span class="n">tableau</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">WeightedPermutation</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">))]</span>

    <span class="c1"># Apply the &quot;parent map&quot; of Definition 1 in Eqs (37) and (38).</span>
    <span class="c1"># This map removes the box with the highest number from the tableau</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tableau</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">remove_l</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t2</span>
    <span class="n">tableau_bar</span> <span class="o">=</span> <span class="p">[</span><span class="n">remove_l</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tableau</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">tableau_bar</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">tableau_bar</span> <span class="o">=</span> <span class="n">tableau_bar</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Compute the projector associated with the parent tableau</span>
    <span class="n">e_bar</span> <span class="o">=</span> <span class="n">make_young_projector</span><span class="p">(</span><span class="n">tableau_bar</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">compose_permutation_algebra_elements</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">compose_permutation_algebra_elements</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]))</span>

    <span class="c1"># Get symmetrizer each row</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">tableau</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symmetrizer</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="o">*</span><span class="n">ps</span><span class="p">)</span>

    <span class="c1"># Get antisymmetrizer for each column</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tableau_t</span> <span class="o">=</span> <span class="n">transpose_tableau</span><span class="p">(</span><span class="n">tableau</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">tableau_t</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symmetrizer</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="o">*</span><span class="n">ns</span><span class="p">)</span>

    <span class="c1"># Compute the normalizaiton</span>
    <span class="n">hook_norm</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tableau</span><span class="p">):</span>
        <span class="n">hook_r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">tableau_t</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">hook_c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span>
            <span class="n">hook_norm</span> <span class="o">*=</span> <span class="p">(</span><span class="n">hook_r</span> <span class="o">+</span> <span class="n">hook_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Apply the recursive definition in Eq (86)</span>
    <span class="c1"># The product &quot;(symmetrizer) x (antisymmetrizer)&quot; is Eq (26)</span>
    <span class="n">proj_unnorm</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">e_bar</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">e_bar</span><span class="p">)</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">WeightedPermutation</span><span class="p">(</span><span class="n">weight</span> <span class="o">/</span> <span class="n">hook_norm</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span> <span class="ow">in</span> <span class="n">proj_unnorm</span> <span class="p">]</span>
    <span class="k">return</span> <span class="n">proj</span></div>



<span class="c1">#################################</span>
<span class="c1"># Orbit-representation matrices #</span>
<span class="c1">#################################</span>


<div class="viewcode-block" id="make_momentum_orbit_rep_matrix">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_momentum_orbit_rep_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">make_momentum_orbit_rep_matrix</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">group_element</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the momentum-orbit representation matrix associated with the</span>
<span class="sd">    action of a group element on an orbit of vectors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : list</span>
<span class="sd">        The orbit of an ordered set of vectors under the group</span>
<span class="sd">    group_element : array_like</span>
<span class="sd">        The group element which will act on all the elements of the orbit</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    permutation : ``(|O|, |O|)`` ndarray</span>
<span class="sd">        The representation matrix, which happens to be a permutation matrix.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A group acts on a vector to generate an orbit O. When the group then acts</span>
<span class="sd">    on the orbit, the result is a permutation of the vectors in the orbit.</span>
<span class="sd">    The permutation can be represented as a square matrix of size ``|O|x|O|``,</span>
<span class="sd">    where ``|O|`` is the size of the orbit. The full set of these matrices (with</span>
<span class="sd">    one for each group element) is itself a group representation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
    <span class="n">permutation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># Note: the group element acts on each momentum vector within &quot;momenta&quot;</span>
    <span class="n">permuted_orbit</span> <span class="o">=</span>\
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ab,ib-&gt;ia&quot;</span><span class="p">,</span> <span class="n">group_element</span><span class="p">,</span> <span class="n">momenta</span><span class="p">)</span> <span class="k">for</span> <span class="n">momenta</span> <span class="ow">in</span> <span class="n">orbit</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vec_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orbit</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">vec_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">permuted_orbit</span><span class="p">):</span>
            <span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vec_i</span><span class="o">-</span><span class="n">vec_j</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">permutation</span></div>



<div class="viewcode-block" id="make_momentum_orbit_rep">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_momentum_orbit_rep">[docs]</a>
<span class="k">def</span> <span class="nf">make_momentum_orbit_rep</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the representation of a group G acting on an orbit O.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orbit : list</span>
<span class="sd">        The orbit of an ordered set of vectors under the group</span>
<span class="sd">    group : ``(|G|, 3, 3)`` array_like</span>
<span class="sd">        The group matrices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    representation : ``(|G|, |O|, |O|)`` ndarray</span>
<span class="sd">        The momentum-representation matrices :math:`D_{m,m&#39;}(R)` for all</span>
<span class="sd">        :math:`R \in G`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">make_momentum_orbit_rep_matrix</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group</span><span class="p">])</span></div>



<div class="viewcode-block" id="make_momentum_spin_rep">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_momentum_spin_rep">[docs]</a>
<span class="k">def</span> <span class="nf">make_momentum_spin_rep</span><span class="p">(</span><span class="n">Dmm</span><span class="p">,</span> <span class="o">*</span><span class="n">Dspin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the combined momentum-spin representation matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Dmm : ``(|G|,|O|,|O|)`` ndarray</span>
<span class="sd">        The momentum-representation matrices.</span>
<span class="sd">    *Dspin : ``(|G^D|, |\Gamma|, |\Gamma|)`` ndarray(s)</span>
<span class="sd">        The spin irrep matrices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dmm_spin : ``(|G^D|, dim_total, dim_total)`` ndarray</span>
<span class="sd">        The combined momomentum-spin representation matrices, where the total</span>
<span class="sd">        dimension is given by dim_total = ``|O|x|irrep1|x|irrep2|x...x|irrepN|``.</span>
<span class="sd">        As should be expected, the proudct includes all the representations</span>
<span class="sd">        appearing in the list of &quot;Dspin&quot; matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Dspin</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># No spin irrep matrices are present</span>
        <span class="k">return</span> <span class="n">Dmm</span>

    <span class="n">dim_single</span> <span class="o">=</span> <span class="n">Dmm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dim_double</span> <span class="o">=</span> <span class="n">Dspin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_double</span><span class="p">):</span>
        <span class="n">tensors</span> <span class="o">=</span> <span class="p">[</span><span class="n">Dmm</span><span class="p">[</span><span class="n">idx</span><span class="o">%</span><span class="n">dim_single</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">Dmumu</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">Dmumu</span> <span class="ow">in</span> <span class="n">Dspin</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">,</span> <span class="n">tensors</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>



<span class="c1">##########################</span>
<span class="c1"># Bosonic irrep matrices #</span>
<span class="c1">##########################</span>


<div class="viewcode-block" id="make_irrep_matrix">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_irrep_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">make_irrep_matrix</span><span class="p">(</span><span class="n">polarizations</span><span class="p">,</span> <span class="n">group_element</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the irrep matrix associated with a group element using the</span>
<span class="sd">    algebraic method in terms of polarization tensors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polarizations : list</span>
<span class="sd">        The polarization tensors specifying the basis functions for the irrep</span>
<span class="sd">    group_element : ``(3, 3)`` array_like</span>
<span class="sd">        The group element.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    irrep_matrix : ``(|\Gamma|, |\Gamma|)`` ndarray</span>
<span class="sd">        The irrep matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polarizations</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor_inner</span><span class="p">(</span>
            <span class="n">polarizations</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">transform</span><span class="p">(</span><span class="n">polarizations</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">group_element</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">arr</span></div>



<div class="viewcode-block" id="make_irrep">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_irrep">[docs]</a>
<span class="k">def</span> <span class="nf">make_irrep</span><span class="p">(</span><span class="n">polarizations</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the irrep matrices D_{mu, mu&#39;}(g).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polarizations : list</span>
<span class="sd">        The polarization tensors specifying the basis functions for the irrep.</span>
<span class="sd">    group: ``(|G|, 3, 3)`` array_like</span>
<span class="sd">        The group matrices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    irrep : ``(|G|, |\Gamma|, |\Gamma|)`` ndarray</span>
<span class="sd">        The irrep matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">make_irrep_matrix</span><span class="p">(</span><span class="n">polarizations</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group</span><span class="p">])</span></div>


<span class="c1">############################</span>
<span class="c1"># Fermionic irrep matrices #</span>
<span class="c1">############################</span>

<div class="viewcode-block" id="make_irrep_matrix_spinor">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_irrep_matrix_spinor">[docs]</a>
<span class="k">def</span> <span class="nf">make_irrep_matrix_spinor</span><span class="p">(</span><span class="n">irrep_basis</span><span class="p">,</span> <span class="n">group_element</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the spinorial irrep matrix associated with a group element,</span>
<span class="sd">    given a basis for the irrep.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    irrep_basis : list</span>
<span class="sd">        The spinor basis spanning the irrep</span>
<span class="sd">    group_element : ``(4, 4)`` ndarray</span>
<span class="sd">        The &quot;spinorial&quot; group element.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    irrep_matrix : ``(|\Gamma|, |\Gamma|)`` ndarray</span>
<span class="sd">        The irrep matrix.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Each basis state should be a list of tuples &quot;(coefficient, SpinorTuple)&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">group_element</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="s2">&quot;group element should act on spinors&quot;</span>

    <span class="k">def</span> <span class="nf">_make_spinor_array_lincombo</span><span class="p">(</span><span class="n">basis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a linear combination of &quot;spinor states&quot; inside a suitable</span>
<span class="sd">        tensor product space of spin-1/2 states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">c</span><span class="o">*</span><span class="n">make_spinor_array</span><span class="p">(</span><span class="n">ket</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">ket</span> <span class="ow">in</span> <span class="n">state</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="c1"># Grab total j, making sure that it is specified consistently for all states</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">psi</span><span class="o">.</span><span class="n">j</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">psi</span> <span class="ow">in</span> <span class="n">irrep_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="n">nprod</span> <span class="o">=</span> <span class="n">get_nprod</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="n">cgs</span> <span class="o">=</span> <span class="n">_make_spinor_array_lincombo</span><span class="p">(</span><span class="n">irrep_basis</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">cgs</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">@</span> <span class="n">cgs</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">irrep_basis</span><span class="p">))),</span>\
        <span class="sa">f</span><span class="s2">&quot;Problem with state normalization </span><span class="si">{</span><span class="n">cgs</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">irrep_basis</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Construct representation D(g) of g acting on the tensor product space</span>
    <span class="n">irrep_mat</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">,</span> <span class="n">nprod</span><span class="o">*</span><span class="p">[</span><span class="n">group_element</span><span class="p">])</span>

    <span class="c1"># Compute matrix of overlaps M_{a,b} &lt;a|D(g)|b&gt;,</span>
    <span class="c1"># indexed by the states a, b in the basis of the tensor product space</span>
    <span class="k">return</span> <span class="n">cgs</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">@</span> <span class="n">irrep_mat</span> <span class="o">@</span> <span class="n">cgs</span><span class="o">.</span><span class="n">T</span></div>



<div class="viewcode-block" id="make_irrep_spinor">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_irrep_spinor">[docs]</a>
<span class="k">def</span> <span class="nf">make_irrep_spinor</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the spinorial irrep matrices D_{mu, mu&#39;}(g).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    basis : list</span>
<span class="sd">        The spinor basis spanning the irrep</span>
<span class="sd">    group : ``(|G|, 4, 4)`` list or array_like</span>
<span class="sd">        The group matrices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    irrep : ``(|G|, |\Gamma|, |\Gamma|)`` ndarray</span>
<span class="sd">        The irrep matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">make_irrep_matrix_spinor</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group</span><span class="p">])</span></div>



<div class="viewcode-block" id="make_irrep_from_group">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_irrep_from_group">[docs]</a>
<span class="k">def</span> <span class="nf">make_irrep_from_group</span><span class="p">(</span><span class="n">little_group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the irrep matrices associated with a particular little group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    little_group : ``(|G|, 3, 3)`` ndarray</span>
<span class="sd">        The matrices for the little group G.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dmumu : dict</span>
<span class="sd">        The irrep matrices as a dict. The keys give the name of the irrep.</span>
<span class="sd">        The values contain the irrep matrices themselves, each with shape</span>
<span class="sd">        ``(|G|, |\Gamma|, |\Gamma|)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">little_group_name</span> <span class="o">=</span> <span class="n">identify_stabilizer</span><span class="p">(</span><span class="n">little_group</span><span class="p">)</span>

    <span class="c1"># Compute normalized polarizations</span>
    <span class="n">basis_arrs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">irrep_name</span> <span class="ow">in</span> <span class="n">basis_functions</span><span class="o">.</span><span class="n">basis_fcns</span><span class="p">[</span><span class="n">little_group_name</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">fcn</span> <span class="ow">in</span> <span class="n">basis_functions</span><span class="o">.</span><span class="n">basis_fcns</span><span class="p">[</span><span class="n">little_group_name</span><span class="p">][</span><span class="n">irrep_name</span><span class="p">]:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">polarize</span><span class="p">(</span><span class="n">fcn</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">irrep_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">basis_arrs</span><span class="p">:</span>
                <span class="n">basis_arrs</span><span class="p">[</span><span class="n">irrep_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">basis_arrs</span><span class="p">[</span><span class="n">irrep_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="c1"># Compute irrep matrices</span>
    <span class="n">Dmumu</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">irrep_name</span><span class="p">,</span> <span class="n">polarizations</span> <span class="ow">in</span> <span class="n">basis_arrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">Dmumu</span><span class="p">[</span><span class="n">irrep_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_irrep</span><span class="p">(</span><span class="n">polarizations</span><span class="p">,</span> <span class="n">little_group</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Dmumu</span></div>



<div class="viewcode-block" id="make_irrep_from_groupD">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_irrep_from_groupD">[docs]</a>
<span class="k">def</span> <span class="nf">make_irrep_from_groupD</span><span class="p">(</span><span class="n">little_group</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes double-cover irrep matrices associated with a given little group,</span>
<span class="sd">    including both spinorial and bosonic irreps.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    little_group : ``(|G|, 3, 3)`` ndarray</span>
<span class="sd">        The matrices for the little group G.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dmumu_double : dict</span>
<span class="sd">        The irrep matrices as a dict. The keys give the name of the irrep.</span>
<span class="sd">        The values contain the irrep matrices themselves, each with shape</span>
<span class="sd">        ``(|G^D|, |\Gamma|, |\Gamma|)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">little_name</span> <span class="o">=</span> <span class="n">identify_stabilizer</span><span class="p">(</span><span class="n">little_group</span><span class="p">)</span>
    <span class="n">little_double</span> <span class="o">=</span> <span class="n">make_spinorial_little_group</span><span class="p">(</span><span class="n">little_group</span><span class="p">)</span>

    <span class="c1"># Spinorial irreps</span>
    <span class="n">basis_ohd</span> <span class="o">=</span> <span class="n">basis_functions</span><span class="o">.</span><span class="n">basis_spinors</span><span class="p">[</span><span class="n">little_name</span><span class="p">]</span>
    <span class="n">Dmumu_double</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">irrep_name</span><span class="p">,</span> <span class="n">basis</span> <span class="ow">in</span> <span class="n">basis_ohd</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">Dmumu_double</span><span class="p">[</span><span class="n">irrep_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_irrep_spinor</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">little_double</span><span class="p">)</span>

    <span class="c1"># Bosonic irreps -- double-cover irreps from standard single-cover irreps</span>
    <span class="n">Dmumu_single</span> <span class="o">=</span> <span class="n">make_irrep_from_group</span><span class="p">(</span><span class="n">little_group</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">irrep_name</span><span class="p">,</span> <span class="n">irrep_mats</span> <span class="ow">in</span> <span class="n">Dmumu_single</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">Dmumu_double</span><span class="p">[</span><span class="n">irrep_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">irrep_mats</span><span class="p">,</span> <span class="n">irrep_mats</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Dmumu_double</span></div>



<span class="c1">##################################</span>
<span class="c1"># Block diagonalization matrices #</span>
<span class="c1">##################################</span>


<div class="viewcode-block" id="orth">
<a class="viewcode-back" href="../../code.html#mhi.mhi.orth">[docs]</a>
<span class="k">def</span> <span class="nf">orth</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes an orthonormal basis for the row space.</span>

<span class="sd">    This implementation constructs the basis for the row space using the</span>
<span class="sd">    Gram-Schmidt algorithm applied to the rows of the input array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    basis : ndarray</span>
<span class="sd">        An orthonormal basis for the row space, with each row corresponding to</span>
<span class="sd">        a basis element.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">new_vec</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="s2">&quot;perpendicular&quot;</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_vec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">new_vec</span> <span class="o">=</span> <span class="n">new_vec</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_vec</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Failed to construct orthogonal basis&quot;</span><span class="p">)</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">@</span> <span class="n">basis</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">))),</span>\
        <span class="s2">&quot;Failure to construct orthonormal basis.&quot;</span>
    <span class="k">return</span> <span class="n">basis</span></div>



<div class="viewcode-block" id="project">
<a class="viewcode-back" href="../../code.html#mhi.mhi.project">[docs]</a>
<span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the paralell or perpendicular projection of a vector with respect</span>
<span class="sd">    to the space spanned by a basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vector : array_like</span>
<span class="sd">    basis : array_like</span>
<span class="sd">        Vectors specifying the basis, with each row corresponding to a vector.</span>
<span class="sd">    direction : {&#39;parallel&#39;, &#39;perpendicular&#39;}</span>
<span class="sd">        Whether to compute the parallel or perpendicular projection.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vector_new : np.array</span>
<span class="sd">        The projected vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nbasis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nbasis</span><span class="p">:</span>
        <span class="c1"># Bail out if the basis is empty</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;parallel&#39;</span><span class="p">,</span> <span class="s1">&#39;perpendicular&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span>
            <span class="sa">f</span><span class="s2">&quot;Unrecongnized direction &#39;</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="s2">&quot;Please specify &#39;parallel&#39; or &#39;perpendicular&#39;.&quot;</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>

    <span class="c1"># Check sizes</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">ncols</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">dim</span><span class="p">,</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">ncols</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incomensurate shapes, </span><span class="si">{</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">vector</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Compute projections</span>
    <span class="n">v_parallel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vector</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w_vec</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">:</span>
        <span class="n">v_parallel</span> <span class="o">=</span> <span class="n">v_parallel</span> <span class="o">+</span> <span class="n">w_vec</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">w_vec</span><span class="p">),</span> <span class="n">vector</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;perpendicular&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vector</span> <span class="o">-</span> <span class="n">v_parallel</span>
    <span class="k">return</span> <span class="n">v_parallel</span>  <span class="c1"># parallel</span></div>



<div class="viewcode-block" id="apply_schur">
<a class="viewcode-back" href="../../code.html#mhi.mhi.apply_schur">[docs]</a>
<span class="k">def</span> <span class="nf">apply_schur</span><span class="p">(</span><span class="n">Dmm</span><span class="p">,</span> <span class="n">Dmumu</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the block diagonalization matrices using Schur&#39;s algorithm,</span>
<span class="sd">    including transition operators to move between rows in a given irrep.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Dmm : ``(|G|, |O|, |O|)`` array_like</span>
<span class="sd">        Momentum-(spin)-representation matrices</span>
<span class="sd">    Dmumu : dict</span>
<span class="sd">        The irrep matrices. The keys give the name of the irrep. The values</span>
<span class="sd">        contain the group irrep matrices, with shape ``(|G|, |\Gamma|, |\Gamma|)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    u_matrix : dict</span>
<span class="sd">        The block diagonalization matrix.</span>
<span class="sd">        The keys are tuples of the form (irrep_name, degeneracy_number).</span>
<span class="sd">        The values are arrays containing the matrices, each of shape</span>
<span class="sd">        ``(|\Gamma|, |O|)``.</span>
<span class="sd">    transition_operators: dict</span>
<span class="sd">        Column of transition operators ``T_{\mu,0}``.</span>
<span class="sd">        The keys are irrep names.</span>
<span class="sd">        The values are ndarrays of shape ``(|\Gamma|, |O|, |O|)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u_matrix</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">transition_operators</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">irrep_name</span> <span class="ow">in</span> <span class="n">Dmumu</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">_</span>  <span class="o">=</span> <span class="n">Dmumu</span><span class="p">[</span><span class="n">irrep_name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># Construct transition operators using Wonderful orthogonality theorem</span>
        <span class="c1"># Comute the column T_{mu,0}, since that&#39;s all that&#39;s needed.</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">Dmm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Dmm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">T</span><span class="p">[</span><span class="n">mu</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i,ijk-&gt;jk&quot;</span><span class="p">,</span>
                                <span class="n">Dmumu</span><span class="p">[</span><span class="n">irrep_name</span><span class="p">][:,</span><span class="n">mu</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span>
                                <span class="n">Dmm</span><span class="p">)</span>
            <span class="n">T</span><span class="p">[</span><span class="n">mu</span><span class="p">]</span> <span class="o">*=</span> <span class="n">dim</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">Dmumu</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># The present irrep doesn&#39;t appear in the decompostion. Carry on.</span>
            <span class="k">continue</span>
        <span class="n">transition_operators</span><span class="p">[</span><span class="n">irrep_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span>

        <span class="c1"># Count the number of degenerate copies</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="n">orth</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="o">==</span> <span class="n">rank</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;Failure: expected len(basis)=rank. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Found len(basis)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span><span class="si">}</span><span class="s2"> and rank=</span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Located irrep </span><span class="si">{</span><span class="n">irrep_name</span><span class="si">}</span><span class="s2"> with degeneracy </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">kappa</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span>
            <span class="n">vecs</span> <span class="o">=</span> <span class="p">[</span><span class="n">basis</span><span class="p">[</span><span class="n">kappa</span><span class="p">]]</span>
            <span class="c1"># Construct subsequent rows with transition operators T_{mu,0}</span>
            <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
                <span class="n">new_vec</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">mu</span><span class="p">]</span> <span class="o">@</span> <span class="n">basis</span><span class="p">[</span><span class="n">kappa</span><span class="p">]</span>
                <span class="n">new_vec</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_vec</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_vec</span><span class="p">),</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Zero vector encountered by T[</span><span class="si">{</span><span class="n">mu</span><span class="si">}</span><span class="s2">,0]&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_vec</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Normalization broken during T[</span><span class="si">{</span><span class="n">mu</span><span class="si">}</span><span class="s2">,0].&quot;</span><span class="p">)</span>
                <span class="n">vecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_vec</span><span class="p">)</span>
            <span class="n">vecs</span> <span class="o">=</span> <span class="n">rephase</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vecs</span><span class="p">),</span> <span class="n">irrep_name</span><span class="p">)</span>
            <span class="n">u_matrix</span><span class="p">[(</span><span class="n">irrep_name</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)]</span> <span class="o">=</span> <span class="n">vecs</span>

        <span class="k">for</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">vec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vecs</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">irrep_name</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="s2">&quot;norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span>

    <span class="c1"># Check results for consistency</span>
    <span class="n">test_row_orthogonality</span><span class="p">(</span><span class="n">u_matrix</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">test_degenerate_orthogonality</span><span class="p">(</span><span class="n">u_matrix</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">test_block_diagonalization</span><span class="p">(</span><span class="n">Dmm</span><span class="p">,</span> <span class="n">Dmumu</span><span class="p">,</span> <span class="n">u_matrix</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u_matrix</span><span class="p">,</span> <span class="n">transition_operators</span></div>



<div class="viewcode-block" id="rephase">
<a class="viewcode-back" href="../../code.html#mhi.mhi.rephase">[docs]</a>
<span class="k">def</span> <span class="nf">rephase</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">irrep</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a phase convention to block diagonalization matrices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ``(|\Gamma|, |O|)`` array_like</span>
<span class="sd">        Table specifiying the matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ``(|\Gamma|, |O|)`` ndarray</span>
<span class="sd">        The table with appropriate phases applied.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The phase convention is as follows:</span>
<span class="sd">      - For a generic irrep, the phase is chosen such that the first nonzero</span>
<span class="sd">        entry of the first row (:math:`\mu=1`) is real and positive.</span>
<span class="sd">      - For the irreps :math:`T_2^+` and :math:`T_2^-` only, the phase is chosen</span>
<span class="sd">        such that the second row (:math:`\mu=2`) is purely imaginary with a negative</span>
<span class="sd">        imaginary part. This choice matches the basis-vector conventions of</span>
<span class="sd">        Basak et al., where a particular combination of spheric harmonics</span>
<span class="sd">        :math:`(Y_2^2 - Y_2^{-2})` is used as the :math:`\mu=2` basis vector for T2.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] S. Basak et al., &quot;Clebsch-Gordan construction of lattice interpolating</span>
<span class="sd">       fields for excited baryons&quot;, Phys. Rev. D 72, 074501 (2005),</span>
<span class="sd">       [arXiv:hep-lat/0508018].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Special convention to match Basak et al.</span>
    <span class="k">if</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;T2p&quot;</span><span class="p">,</span> <span class="s2">&quot;T2m&quot;</span><span class="p">):</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Zero vector found while rephasing </span><span class="si">{</span><span class="n">irrep</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">])))</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">phase</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="mi">270</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Bad angle, phi=</span><span class="si">{</span><span class="n">phi</span><span class="si">}</span><span class="s2"> deg.&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp</span><span class="p">)),</span> <span class="s2">&quot;Bad length.&quot;</span>

    <span class="c1"># Convention for generic irreps</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Zero vector found while rephasing </span><span class="si">{</span><span class="n">irrep</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">phase</span> <span class="o">*</span> <span class="n">arr</span></div>



<span class="c1">###################</span>
<span class="c1"># Driver function #</span>
<span class="c1">###################</span>

<div class="viewcode-block" id="load_particle_info">
<a class="viewcode-back" href="../../code.html#mhi.mhi.load_particle_info">[docs]</a>
<span class="k">def</span> <span class="nf">load_particle_info</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads tabulated information for particle names, spins (boson vs fermion),</span>
<span class="sd">    and spin irreps.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str or None</span>
<span class="sd">        The path to the input yaml file with the tabulated data</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    table : dict</span>
<span class="sd">        The particle information in the form {&lt;name&gt; : (&lt;fermion?&gt;, &lt;irrep&gt;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ParticleInfo</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;SpinIrrep&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;is_fermion&quot;</span><span class="p">,</span> <span class="s2">&quot;irrep&quot;</span><span class="p">,</span> <span class="s2">&quot;spin_dim&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">resolve</span><span class="p">(),</span> <span class="s1">&#39;particles.yaml&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifile</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ParticleInfo</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>



<div class="viewcode-block" id="make_pseudoscalar_irrep">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_pseudoscalar_irrep">[docs]</a>
<span class="k">def</span> <span class="nf">make_pseudoscalar_irrep</span><span class="p">(</span><span class="n">little</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instantiates the double-cover irrep matrices associated with a pseudoscalar</span>
<span class="sd">    particle, assumed to transform under the :math:`A_1^-` irrep. Usually this</span>
<span class="sd">    function is used when constructing the `Dspin` matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    little : ``(|G|, 3, 3)`` array_like</span>
<span class="sd">        The little-group matrices associated with some momenta</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pseudoscalar : ``(|G^D|, 1, 1)`` ndarray</span>
<span class="sd">        The A1m irrep matrices restricted to the double cover of the little group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">oh</span> <span class="o">=</span> <span class="n">make_oh</span><span class="p">()</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">gg</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">gg</span> <span class="ow">in</span> <span class="n">oh</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">little</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">pseudoscalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">[</span><span class="n">make_irrep_from_group</span><span class="p">(</span><span class="n">oh</span><span class="p">)[</span><span class="s1">&#39;A1m&#39;</span><span class="p">][</span><span class="n">idxs</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">pseudoscalar</span></div>



<div class="viewcode-block" id="make_spin_half_irrep">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_spin_half_irrep">[docs]</a>
<span class="k">def</span> <span class="nf">make_spin_half_irrep</span><span class="p">(</span><span class="n">little_double</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instantiates the double-cover irrep matrices associated with a spin-half</span>
<span class="sd">    particle, assumed to transform under the :math:`G_1^+` irrep. Usually this</span>
<span class="sd">    function is used when constructing the `Dspin` matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    little_double : ``(|G^D|, 4, 4)`` array_like</span>
<span class="sd">        The spinorial little-group matrices associated with some momenta</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pseudoscalar : ``(|G^D|, 1, 1)`` ndarray</span>
<span class="sd">        The G_1^+ irrep matrices restricted to the double cover of the little group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">make_irrep_spinor</span><span class="p">(</span>
            <span class="n">basis_functions</span><span class="o">.</span><span class="n">basis_spinors</span><span class="p">[</span><span class="s2">&quot;nucleon&quot;</span><span class="p">][</span><span class="s2">&quot;nucleon&quot;</span><span class="p">],</span>
            <span class="n">little_double</span><span class="p">)</span></div>



<div class="viewcode-block" id="make_Dspin">
<a class="viewcode-back" href="../../code.html#mhi.mhi.make_Dspin">[docs]</a>
<span class="k">def</span> <span class="nf">make_Dspin</span><span class="p">(</span><span class="n">spin_irreps</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">little_double</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a list of spin irrep matrices for the specified particles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spin_irreps : list</span>
<span class="sd">        The names of the particles&#39; spin irreps as strings, e.g., [&#39;A1m&#39;, &#39;G1p&#39;]</span>
<span class="sd">    little : ``(|G|, 3, 3)`` array_like</span>
<span class="sd">        The little-group matrices associated with some momenta</span>
<span class="sd">    little_double : ``(|G^D|, 4, 4)`` array_like</span>
<span class="sd">        The spinorial little-group matrices associated with some momenta</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dspin : list</span>
<span class="sd">        The &quot;spin&quot; irrep matrices for each particle</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">spin_irreps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="s1">&#39;A1m&#39;</span> <span class="ow">in</span> <span class="n">spin_irreps</span><span class="p">:</span>
        <span class="n">pseudoscalar</span> <span class="o">=</span> <span class="n">make_pseudoscalar_irrep</span><span class="p">(</span><span class="n">little</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;G1p&#39;</span> <span class="ow">in</span> <span class="n">spin_irreps</span><span class="p">:</span>
        <span class="n">spin_half</span> <span class="o">=</span> <span class="n">make_spin_half_irrep</span><span class="p">(</span><span class="n">little_double</span><span class="p">)</span>
    <span class="n">Dspin</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="n">spin_irreps</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">irrep</span> <span class="o">==</span> <span class="s1">&#39;A1m&#39;</span><span class="p">:</span>
            <span class="n">Dspin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pseudoscalar</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">irrep</span> <span class="o">==</span> <span class="s1">&#39;G1p&#39;</span><span class="p">:</span>
            <span class="n">Dspin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spin_half</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected irrep &#39;</span><span class="si">{</span><span class="n">irrep</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Dspin</span></div>



<div class="viewcode-block" id="identify_spin_dim">
<a class="viewcode-back" href="../../code.html#mhi.mhi.identify_spin_dim">[docs]</a>
<span class="k">def</span> <span class="nf">identify_spin_dim</span><span class="p">(</span><span class="n">irrep</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies the dimension of the specified spin irrep.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    str : irrep</span>
<span class="sd">        The name of the spin irrep, e.g., &#39;A1m&#39; or &#39;G1p&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dim : int</span>
<span class="sd">        The dimension of the irrep</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">basis_functions</span><span class="o">.</span><span class="n">basis_fcns</span><span class="p">,</span> <span class="n">basis_functions</span><span class="o">.</span><span class="n">basis_spinors</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">basis</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">irrep_dict</span> <span class="ow">in</span> <span class="n">basis</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">irrep_name</span><span class="p">,</span> <span class="n">basis_fcns</span> <span class="ow">in</span> <span class="n">irrep_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">irrep_name</span> <span class="o">==</span> <span class="n">irrep</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis_fcns</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to locate irrep &#39;</span><span class="si">{</span><span class="n">irrep</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="IrrepDecomposition">
<a class="viewcode-back" href="../../code.html#mhi.mhi.IrrepDecomposition">[docs]</a>
<span class="k">class</span> <span class="nc">IrrepDecomposition</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for results of computing the block-diagonalization matrices</span>
<span class="sd">    which project linear combinations of plane-wave states onto irreps of</span>
<span class="sd">    the cubic group.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    decomp : dict</span>
<span class="sd">        The irrep decomposition and change-of-basis matrices.</span>
<span class="sd">        The keys are tuples (irrep_name, degeneracy_idx).</span>
<span class="sd">        The values are the block-diagonalization matrices, given as arrays</span>
<span class="sd">        of shape ``(|Gamma|, |O|)``.</span>
<span class="sd">    orbit : ``(|O|,)`` list of :class:`SpinShellTuple`</span>
<span class="sd">        The &quot;extended&quot; spin-momentum orbit, where each element is a</span>
<span class="sd">        :class:`SpinShellTuple` specifying momentum and spin indices.</span>
<span class="sd">    Dmm : ``(|G|, |O|, |O|)``, ndarray</span>
<span class="sd">        The (reducible) representation matrices associated with the orbit.</span>
<span class="sd">    Dmumu : ``(|G|, |Gamma|, |Gamma|)``, ndarray</span>
<span class="sd">        The irrep matrices</span>
<span class="sd">    little_name : str</span>
<span class="sd">        The name of the little group leaving the total momentum invariant</span>
<span class="sd">    stab_name : str</span>
<span class="sd">        The name of the stabilizer group leaving the ordered set of</span>
<span class="sd">        momenta invariant.</span>
<span class="sd">    transition_operators: dict</span>
<span class="sd">        Column of transition operators :math:`T_{\mu,0}`.</span>
<span class="sd">        The keys are irrep names.</span>
<span class="sd">        The values are ndarrays of shape ``(|Gamma|, |O|, |O|)``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Projection onto cubic-group irreps requires two pieces.</span>
<span class="sd">      - A basis of momentum plane-wave correlation functions, presumably</span>
<span class="sd">        computed using lattice QCD.</span>
<span class="sd">      - The block-diagonalization matrices computed using this module.</span>

<span class="sd">    To carry out this projection, the basis of correlation functions must</span>
<span class="sd">    have the same order as the orbit used to compute the block-diagonalization</span>
<span class="sd">    matrices. The required ordering can be seen by examining the</span>
<span class="sd">    &quot;orbit.&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decomp</span><span class="p">,</span> <span class="n">orbit</span><span class="p">,</span> <span class="n">Dmm</span><span class="p">,</span> <span class="n">Dmumu</span><span class="p">,</span> <span class="n">little_name</span><span class="p">,</span> <span class="n">stab_name</span><span class="p">,</span> <span class="n">transition_operators</span><span class="p">):</span>
        <span class="c1"># Check expected shape of block diagonalization matrices</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">decomp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
        <span class="c1"># Check expected shape of (reducible) representaiton matrices</span>
        <span class="k">if</span> <span class="n">Dmm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">Dmm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">Dmm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Dmm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">decomp</span> <span class="o">=</span> <span class="n">decomp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orbit</span> <span class="o">=</span> <span class="n">orbit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dmm</span> <span class="o">=</span> <span class="n">Dmm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dmumu</span> <span class="o">=</span> <span class="n">Dmumu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_little_name</span> <span class="o">=</span> <span class="n">little_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stab_name</span> <span class="o">=</span> <span class="n">stab_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_operators</span> <span class="o">=</span> <span class="n">transition_operators</span>

<div class="viewcode-block" id="IrrepDecomposition.format">
<a class="viewcode-back" href="../../code.html#mhi.mhi.IrrepDecomposition.format">[docs]</a>
    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Formats the irrep decomposition as text string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        latex : bool</span>
<span class="sd">            Whether or not return a latex-formatted sting</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : str</span>
<span class="sd">            The irrep decomposition, e.g., ``&quot;A1p + A2p + 2*Ep&quot;`` or</span>
<span class="sd">            ``&quot;$A_1^+ \oplus A_2^+ \oplus 2E^+$&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Count the degenerate copies</span>
        <span class="n">irrep_counts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">irrep</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">irrep</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">irrep_counts</span><span class="p">:</span>
                <span class="n">irrep_counts</span><span class="p">[</span><span class="n">irrep</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">irrep_counts</span><span class="p">[</span><span class="n">irrep</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Sort the names according to a conventional ordering</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">irrep_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">degeneracies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">irrep_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">names</span><span class="p">,</span> <span class="n">degeneracies</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">degeneracies</span><span class="p">),</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_irrep_priority</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot; \oplus &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">degen</span><span class="si">}</span><span class="s2">*</span><span class="si">{</span><span class="n">irrep</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">degen</span><span class="p">,</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">degeneracies</span><span class="p">,</span> <span class="n">names</span><span class="p">)])</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_irrep_to_latex</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;1*&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">output</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot; + &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">degen</span><span class="si">}</span><span class="s2">*</span><span class="si">{</span><span class="n">irrep</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">degen</span><span class="p">,</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">degeneracies</span><span class="p">,</span> <span class="n">names</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">output</span></div>


    <span class="k">def</span> <span class="nf">_irrep_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irrep_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the priority of an irrep for sorting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        irrep_name : str</span>
<span class="sd">            The irrep name</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        priority : int</span>
<span class="sd">            The priority of the irrep compared to others, for use in sorting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ordered_irreps</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;A1p&#39;</span><span class="p">,</span> <span class="s1">&#39;A2p&#39;</span><span class="p">,</span> <span class="s1">&#39;Ep&#39;</span><span class="p">,</span> <span class="s1">&#39;T1p&#39;</span><span class="p">,</span> <span class="s1">&#39;T2p&#39;</span><span class="p">,</span>
            <span class="s1">&#39;A1m&#39;</span><span class="p">,</span> <span class="s1">&#39;A2m&#39;</span><span class="p">,</span> <span class="s1">&#39;Em&#39;</span><span class="p">,</span> <span class="s1">&#39;T1m&#39;</span><span class="p">,</span> <span class="s1">&#39;T2m&#39;</span><span class="p">,</span>
            <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A2&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B1&#39;</span><span class="p">,</span> <span class="s1">&#39;B2&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span>
            <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;F1&quot;</span><span class="p">,</span> <span class="s2">&quot;F2&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;G1&quot;</span><span class="p">,</span> <span class="s2">&quot;G2&quot;</span><span class="p">,</span> <span class="s2">&quot;G1p&quot;</span><span class="p">,</span> <span class="s2">&quot;G2p&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Hp&quot;</span><span class="p">,</span> <span class="s2">&quot;G1m&quot;</span><span class="p">,</span> <span class="s2">&quot;G2m&quot;</span><span class="p">,</span> <span class="s2">&quot;Hm&quot;</span>
        <span class="p">]</span>
        <span class="n">priority</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ordered_irreps</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ordered_irreps</span><span class="p">))))</span>
        <span class="k">if</span> <span class="n">irrep_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ordered_irreps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad irrep_name&quot;</span><span class="p">,</span> <span class="n">irrep_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">priority</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">irrep_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_irrep_to_latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts irrep names from internal string representations to latex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output : str</span>
<span class="sd">            Some text containing the internal string representations of the irrep names</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : str</span>
<span class="sd">            The text, but with appropriate replacements, e.g., &#39;A1p&#39; -&gt; &#39;A_1^+.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">irrep_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;A1p&#39;</span><span class="p">:</span> <span class="s1">&#39;A_1^+&#39;</span><span class="p">,</span>
            <span class="s1">&#39;A2p&#39;</span><span class="p">:</span> <span class="s1">&#39;A_2^+&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Ep&#39;</span><span class="p">:</span> <span class="s1">&#39;E^+&#39;</span><span class="p">,</span>
            <span class="s1">&#39;T1p&#39;</span><span class="p">:</span> <span class="s1">&#39;T_1^+&#39;</span><span class="p">,</span>
            <span class="s1">&#39;T2p&#39;</span><span class="p">:</span> <span class="s1">&#39;T_2^+&#39;</span><span class="p">,</span>
            <span class="s1">&#39;A1m&#39;</span><span class="p">:</span> <span class="s1">&#39;A_1^-&#39;</span><span class="p">,</span>
            <span class="s1">&#39;A2m&#39;</span><span class="p">:</span>  <span class="s1">&#39;A_2^-&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Em&#39;</span><span class="p">:</span>  <span class="s1">&#39;E^-&#39;</span><span class="p">,</span>
            <span class="s1">&#39;T1m&#39;</span><span class="p">:</span>  <span class="s1">&#39;T_1^-&#39;</span><span class="p">,</span>
            <span class="s1">&#39;T2m&#39;</span><span class="p">:</span> <span class="s1">&#39;T_2^-&#39;</span><span class="p">,</span>
            <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span>
            <span class="s1">&#39;A1&#39;</span><span class="p">:</span> <span class="s1">&#39;A_1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;A2&#39;</span><span class="p">:</span> <span class="s1">&#39;A_2&#39;</span><span class="p">,</span>
            <span class="s1">&#39;B&#39;</span><span class="p">:</span>  <span class="s1">&#39;B&#39;</span><span class="p">,</span>
            <span class="s1">&#39;B1&#39;</span><span class="p">:</span>  <span class="s1">&#39;B_1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;B2&#39;</span><span class="p">:</span>  <span class="s1">&#39;B_2&#39;</span><span class="p">,</span>
            <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span>
            <span class="s2">&quot;F&quot;</span><span class="p">:</span>  <span class="s2">&quot;F&quot;</span><span class="p">,</span>
            <span class="s2">&quot;F1&quot;</span><span class="p">:</span>  <span class="s2">&quot;F_1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;F2&quot;</span><span class="p">:</span>  <span class="s2">&quot;F_2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;G&quot;</span><span class="p">:</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span>
            <span class="s2">&quot;G1&quot;</span><span class="p">:</span> <span class="s2">&quot;G_1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;G2&quot;</span><span class="p">:</span> <span class="s2">&quot;G_2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;G1p&quot;</span><span class="p">:</span> <span class="s2">&quot;G_1^+&quot;</span><span class="p">,</span>
            <span class="s2">&quot;G2p&quot;</span><span class="p">:</span> <span class="s2">&quot;G_2^+&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Hp&quot;</span><span class="p">:</span> <span class="s2">&quot;H^+&quot;</span><span class="p">,</span>
            <span class="s2">&quot;G1m&quot;</span><span class="p">:</span> <span class="s2">&quot;G_1^-&quot;</span><span class="p">,</span>
            <span class="s2">&quot;G2m&quot;</span><span class="p">:</span> <span class="s2">&quot;G_2^-&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Hm&quot;</span><span class="p">:</span> <span class="s2">&quot;H^-&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">irrep_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_format_group_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Formats the group name in Latex, e.g., &#39;C2R&#39; -&gt; &#39;$C_2^R$&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the group</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        name_latex : str</span>
<span class="sd">            The name of the group in Latex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;C2R&#39;</span><span class="p">:</span> <span class="s1">&#39;C_2^R&#39;</span><span class="p">,</span>
            <span class="s1">&#39;C2P&#39;</span><span class="p">:</span> <span class="s1">&#39;C_2^P&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Oh&#39;</span><span class="p">:</span> <span class="s1">&#39;O_h&#39;</span><span class="p">,</span>
            <span class="s1">&#39;C4v&#39;</span><span class="p">:</span> <span class="s1">&#39;C_4^v&#39;</span><span class="p">,</span>
            <span class="s1">&#39;C3v&#39;</span><span class="p">:</span> <span class="s1">&#39;C_3^v&#39;</span><span class="p">,</span>
            <span class="s1">&#39;C2v&#39;</span><span class="p">:</span> <span class="s1">&#39;C_2^v&#39;</span><span class="p">,</span>
            <span class="s1">&#39;C1&#39;</span><span class="p">:</span> <span class="s1">&#39;C_1&#39;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="s1">&#39;$&#39;</span> <span class="o">+</span> <span class="n">name_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span>

<div class="viewcode-block" id="IrrepDecomposition.little_name">
<a class="viewcode-back" href="../../code.html#mhi.mhi.IrrepDecomposition.little_name">[docs]</a>
    <span class="k">def</span> <span class="nf">little_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of the little group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        latex : bool</span>
<span class="sd">            Whether or not return a latex-formatted sting</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        little_name : str</span>
<span class="sd">            The name of the little group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_group_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_little_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_little_name</span></div>


<div class="viewcode-block" id="IrrepDecomposition.stab_name">
<a class="viewcode-back" href="../../code.html#mhi.mhi.IrrepDecomposition.stab_name">[docs]</a>
    <span class="k">def</span> <span class="nf">stab_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of the stabilizer group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        latex : bool</span>
<span class="sd">            Whether or not return a latex-formatted sting</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stab_name : str</span>
<span class="sd">            The name of the stabilizer group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_group_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stab_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stab_name</span></div>
</div>



<span class="c1">##################</span>
<span class="c1"># Test functions #</span>
<span class="c1">##################</span>


<div class="viewcode-block" id="test_stabilizer">
<a class="viewcode-back" href="../../code.html#mhi.mhi.test_stabilizer">[docs]</a>
<span class="k">def</span> <span class="nf">test_stabilizer</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test identification of the stabilizer group by comparing to known results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">oh_group</span> <span class="o">=</span> <span class="n">make_oh</span><span class="p">()</span>
    <span class="n">known_results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Oh&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
        <span class="s2">&quot;C4v&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
        <span class="s2">&quot;C3v&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="s2">&quot;C2v&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
        <span class="s2">&quot;C2R&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
        <span class="s2">&quot;C2P&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
        <span class="s2">&quot;C1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">ktot</span> <span class="ow">in</span> <span class="n">known_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">stabilizer</span> <span class="o">=</span> <span class="n">make_stabilizer</span><span class="p">(</span><span class="n">ktot</span><span class="p">,</span> <span class="n">oh_group</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">identify_stabilizer</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">)</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span>\
            <span class="sa">f</span><span class="s2">&quot;Error: Misidentified stabilizer for </span><span class="si">{</span><span class="n">ktot</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">known_results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="s2">&quot;C4v&quot;</span><span class="p">,</span> <span class="s2">&quot;C2R&quot;</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span>
        <span class="p">(</span><span class="s2">&quot;C4v&quot;</span><span class="p">,</span> <span class="s2">&quot;C2P&quot;</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">known_names</span><span class="p">,</span> <span class="n">momenta</span> <span class="ow">in</span> <span class="n">known_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">little</span><span class="p">,</span> <span class="n">stab</span> <span class="o">=</span> <span class="n">make_little_and_stabilizer</span><span class="p">(</span><span class="n">momenta</span><span class="p">,</span> <span class="n">oh_group</span><span class="p">)</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">identify_stabilizer</span><span class="p">(</span><span class="n">little</span><span class="p">),</span> <span class="n">identify_stabilizer</span><span class="p">(</span><span class="n">stab</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">names</span> <span class="o">==</span> <span class="n">known_names</span><span class="p">,</span>\
            <span class="sa">f</span><span class="s2">&quot;Error: Misidentified little group and stabilizer for </span><span class="si">{</span><span class="n">momenta</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Success: reference stabilizer groups identified.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="anticommutator">
<a class="viewcode-back" href="../../code.html#mhi.mhi.anticommutator">[docs]</a>
<span class="k">def</span> <span class="nf">anticommutator</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the anticommutator of two matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr1 : array_like</span>
<span class="sd">    arr2 : array_like</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        The anticommutator {arr1, arr2}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">arr1</span> <span class="o">@</span> <span class="n">arr2</span> <span class="o">+</span> <span class="n">arr2</span> <span class="o">@</span> <span class="n">arr1</span></div>



<div class="viewcode-block" id="commutator">
<a class="viewcode-back" href="../../code.html#mhi.mhi.commutator">[docs]</a>
<span class="k">def</span> <span class="nf">commutator</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the commutator of two matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr1 : array_like</span>
<span class="sd">    arr2 : array_like</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        The commutator {arr1, arr2}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">arr1</span> <span class="o">@</span> <span class="n">arr2</span> <span class="o">-</span> <span class="n">arr2</span> <span class="o">@</span> <span class="n">arr1</span></div>



<div class="viewcode-block" id="test_clifford">
<a class="viewcode-back" href="../../code.html#mhi.mhi.test_clifford">[docs]</a>
<span class="k">def</span> <span class="nf">test_clifford</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests the Clifford-algebra condition,</span>
<span class="sd">    :math:`\{\gamma_\mu, \gamma_\nu\} = 2*\eta_{\mu\nu}`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gamma : ``(4, )`` list or ``(4, 4, 4)`` array_like</span>
<span class="sd">        The gamma matrices gamma[i], i=0,1,2,3.</span>
<span class="sd">    eta : ``(4,4)`` ndarray</span>
<span class="sd">        The metric.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Whether to print additional information about successful tests.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">id4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
            <span class="c1"># Clifford-algebra condition</span>
            <span class="n">test</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span> <span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">anticommutator</span><span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="n">mu</span><span class="p">],</span> <span class="n">gamma</span><span class="p">[</span><span class="n">mu</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">eta</span><span class="p">[</span><span class="n">mu</span><span class="p">,</span><span class="n">nu</span><span class="p">]</span><span class="o">*</span><span class="n">id4</span>
            <span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">test</span><span class="p">),</span> <span class="s2">&quot;Clifford algebra not satisfied&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Success: Clifford algebra satisfied.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="test_gamma5">
<a class="viewcode-back" href="../../code.html#mhi.mhi.test_gamma5">[docs]</a>
<span class="k">def</span> <span class="nf">test_gamma5</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">gamma5</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests anticommutation of gamma5,</span>
<span class="sd">    :math:`\{\gamma_\mu, \gamma_5\} = 0`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gamma : ``(4, )`` list or ``(4, 4, 4)`` array_like</span>
<span class="sd">        The gamma matrices gamma[i], i=0,1,2,3.</span>
<span class="sd">    gamma5 : ``(4,4)``</span>
<span class="sd">        The matrix gamma5.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Whether to print additional information about successful tests.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zero4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">anticommutator</span><span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="n">mu</span><span class="p">],</span> <span class="n">gamma5</span><span class="p">)</span> <span class="o">==</span> <span class="n">zero4</span><span class="p">),</span>\
            <span class="sa">f</span><span class="s2">&quot;gamma_</span><span class="si">{</span><span class="n">mu</span><span class="si">}</span><span class="s2"> does not anticommute with gamma5&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Success: gamma5 anticommutes.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="test_row_orthogonality">
<a class="viewcode-back" href="../../code.html#mhi.mhi.test_row_orthogonality">[docs]</a>
<span class="k">def</span> <span class="nf">test_row_orthogonality</span><span class="p">(</span><span class="n">u_matrix</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests the row orthogonality of tables of block-diagonalization matrices,</span>
<span class="sd">    for a given irrep.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u_matrix : dict</span>
<span class="sd">        The block diagonalization matrix.</span>
<span class="sd">        The keys are tuples of the form (irrep_name, degeneracy_number).</span>
<span class="sd">        The values are arrays containing the matrices, each of shape</span>
<span class="sd">        ``(|Gamma|, |O|)``.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Whether to print additional information about successful tests.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">irrep_name</span><span class="p">,</span> <span class="n">kappa</span> <span class="ow">in</span> <span class="n">u_matrix</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">u_matrix</span><span class="p">[(</span><span class="n">irrep_name</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)]</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">@</span> <span class="n">arr</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">)),</span>\
            <span class="sa">f</span><span class="s2">&quot;Failure of row orthogonality </span><span class="si">{</span><span class="n">irrep_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">kappa</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Success: orthogonal rows for </span><span class="si">{</span><span class="n">irrep_name</span><span class="si">}</span><span class="s2">, kappa=</span><span class="si">{</span><span class="n">kappa</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="count_degeneracy">
<a class="viewcode-back" href="../../code.html#mhi.mhi.count_degeneracy">[docs]</a>
<span class="k">def</span> <span class="nf">count_degeneracy</span><span class="p">(</span><span class="n">u_matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts the degeneracy of irreps within the tables of block-diagnoalization</span>
<span class="sd">    matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u_matrix : dict</span>
<span class="sd">        The block diagonalization matrix.</span>
<span class="sd">        The keys are tuples of the form (irrep_name, degeneracy_number).</span>
<span class="sd">        The values are arrays containing the matrices, each of shape</span>
<span class="sd">        ``(|Gamma|, |O|)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    degeneracy : dict</span>
<span class="sd">        The degeneracies, with keys corresponding to the irrep names and values</span>
<span class="sd">        to the counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">degeneracy</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">irrep_name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u_matrix</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">irrep_name</span> <span class="ow">in</span> <span class="n">degeneracy</span><span class="p">:</span>
            <span class="n">degeneracy</span><span class="p">[</span><span class="n">irrep_name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">degeneracy</span><span class="p">[</span><span class="n">irrep_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">degeneracy</span></div>



<div class="viewcode-block" id="test_degenerate_orthogonality">
<a class="viewcode-back" href="../../code.html#mhi.mhi.test_degenerate_orthogonality">[docs]</a>
<span class="k">def</span> <span class="nf">test_degenerate_orthogonality</span><span class="p">(</span><span class="n">u_matrix</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests that tables corresponding to degenerate irreps are orthogonal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u_matrix : dict</span>
<span class="sd">        The block diagonalization matrix.</span>
<span class="sd">        The keys are tuples of the form (irrep_name, degeneracy_number).</span>
<span class="sd">        The values are arrays containing the matrices, each of shape</span>
<span class="sd">        ``(|Gamma|, |O|)``.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Whether to print additional information about successful tests.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">degeneracy</span> <span class="o">=</span> <span class="n">count_degeneracy</span><span class="p">(</span><span class="n">u_matrix</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">irrep_name</span><span class="p">,</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">degeneracy</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k1</span> <span class="o">==</span> <span class="n">k2</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">arr1</span> <span class="o">=</span> <span class="n">u_matrix</span><span class="p">[(</span><span class="n">irrep_name</span><span class="p">,</span> <span class="n">k1</span><span class="p">)]</span>
            <span class="n">arr2</span> <span class="o">=</span> <span class="n">u_matrix</span><span class="p">[(</span><span class="n">irrep_name</span><span class="p">,</span> <span class="n">k2</span><span class="p">)]</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">arr1</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">@</span> <span class="n">arr2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)),</span>\
                <span class="sa">f</span><span class="s2">&quot;Failure of orthogonality </span><span class="si">{</span><span class="n">irrep_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">k1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">k2</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Success: all irreps orthogonal&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="test_block_diagonalization">
<a class="viewcode-back" href="../../code.html#mhi.mhi.test_block_diagonalization">[docs]</a>
<span class="k">def</span> <span class="nf">test_block_diagonalization</span><span class="p">(</span><span class="n">Dmm</span><span class="p">,</span> <span class="n">Dmumu</span><span class="p">,</span> <span class="n">u_matrix</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests the block diagonalization property of the change-of-basis matrices,</span>
<span class="sd">    :math:`D_{\mu\nu} = U^\dagger_{\mu m} D_{mm&#39;} U_{m&#39; \nu}`</span>
<span class="sd">    in terms of the given momentum-shell representation `Dmm`, the</span>
<span class="sd">    block-diagonalization matrix `U`, and the block-diagonal irrep matrix</span>
<span class="sd">    `Dmumu`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Dmm : ``(|G|,|O|,|O|)`` ndarray</span>
<span class="sd">        The momentum-representation matrices.</span>
<span class="sd">    Dmumu : dict</span>
<span class="sd">        The irrep matrices as a dict. The keys give the name of the irrep.</span>
<span class="sd">        The values contain the irrep matrices themselves, each with shape</span>
<span class="sd">        ``(|G|, |Gamma|, |Gamma|)``.</span>
<span class="sd">    u_matrix : dict</span>
<span class="sd">        The block diagonalization matrix.</span>
<span class="sd">        The keys are tuples of the form (irrep_name, degeneracy_number).</span>
<span class="sd">        The values are arrays containing the matrix, each of shape</span>
<span class="sd">        ``(|Gamma|, |O|)``.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Whether to print additional information about successful tests.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">irrep</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">umat</span> <span class="ow">in</span> <span class="n">u_matrix</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
            <span class="n">Dmumu</span><span class="p">[</span><span class="n">irrep</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ia,rab,jb-&gt;rij&quot;</span><span class="p">,</span> <span class="n">umat</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">Dmm</span><span class="p">,</span> <span class="n">umat</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">test</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Failure: block diagonalization </span><span class="si">{</span><span class="n">irrep</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Success: block diagonalization using projection matrices&quot;</span><span class="p">)</span></div>



<span class="c1">############</span>
<span class="c1"># File I/O #</span>
<span class="c1">############</span>

<div class="viewcode-block" id="write_hdf5">
<a class="viewcode-back" href="../../code.html#mhi.mhi.write_hdf5">[docs]</a>
<span class="k">def</span> <span class="nf">write_hdf5</span><span class="p">(</span><span class="n">h5fname</span><span class="p">,</span> <span class="n">result_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes block-diagonalization matrices to HDF5.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5fname : str</span>
<span class="sd">        The name of the output file</span>
<span class="sd">    result_dict : dict</span>
<span class="sd">        The block-diagonalization / change of basis matrices, where each key</span>
<span class="sd">        is a tuple the form (irrep_name, degeneracy) and each key is an ndarray</span>
<span class="sd">        with the associated matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5file</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">irrep_name</span><span class="p">,</span> <span class="n">degeneracy</span><span class="p">),</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">result_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">dpath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;data/</span><span class="si">{</span><span class="n">irrep_name</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">degeneracy</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">dpath</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">h5file</span><span class="p">:</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">h5file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">dpath</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                          <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="n">h5file</span><span class="p">[</span><span class="n">dpath</span><span class="p">]</span>  <span class="c1"># load existing data</span>
                <span class="n">existing</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>      <span class="c1"># assigned new values to data</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">h5file</span><span class="p">[</span><span class="n">dpath</span><span class="p">],</span> <span class="n">data</span><span class="p">),</span>\
                    <span class="sa">f</span><span class="s2">&quot;Error updated values for (</span><span class="si">{</span><span class="n">irrep_name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">degeneracy</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="n">h5file</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></div>



<div class="viewcode-block" id="read_hdf5">
<a class="viewcode-back" href="../../code.html#mhi.mhi.read_hdf5">[docs]</a>
<span class="k">def</span> <span class="nf">read_hdf5</span><span class="p">(</span><span class="n">h5fname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads saved block-diagonalization matrices from HDF5.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5fname : str</span>
<span class="sd">        The name of HDF5 file to read</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result_dict : dict</span>
<span class="sd">        The block-diagonalization / change of basis matrices, where each key</span>
<span class="sd">        is a tuple the form (irrep_name, degeneracy) and each key is an ndarray</span>
<span class="sd">        with the associated matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifile</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">irrep_name</span> <span class="ow">in</span> <span class="n">ifile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">degeneracy</span> <span class="ow">in</span> <span class="n">ifile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">irrep_name</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">irrep_name</span><span class="p">,</span> <span class="n">degeneracy</span><span class="p">)</span>
                <span class="n">result_dict</span><span class="p">[(</span><span class="n">irrep_name</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">degeneracy</span><span class="p">))]</span> <span class="o">=</span>\
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ifile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">irrep_name</span><span class="p">][</span><span class="n">degeneracy</span><span class="p">][:])</span>
    <span class="k">return</span> <span class="n">result_dict</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, William Detmold, William I. Jay, Gurtej Kanwar, Phiala E. Shanahan, and Michael L. Wagman.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.2.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>